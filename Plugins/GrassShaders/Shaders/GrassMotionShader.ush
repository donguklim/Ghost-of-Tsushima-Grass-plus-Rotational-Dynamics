#define PI_VALUE 3.14159265358979323846


struct GrassMotionShaderFunctions
{
    float ShiftSingleAngle(float angle)
    {
        angle = fmod(angle, 2.0 * PI_VALUE);

        if (angle > PI_VALUE)
        {
            angle -= 2.0 * PI_VALUE;
        }
        else if (angle < -PI_VALUE)
        {
            angle += 2.0 * PI_VALUE;
        }

        return angle;
    }

    float4 ShiftAngleVector(float4 angles)
    {
        angles.x = ShiftSingleAngle(angles.x);
        angles.y = ShiftSingleAngle(angles.y);
        angles.z = ShiftSingleAngle(angles.z);
        angles.w = ShiftSingleAngle(angles.w);

        return angles;
    }

    float3 RotateY(float3 vec, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
    
        float3x3 rotationMatrix = float3x3(
            c, 0, -s,
            0, 1, 0,
            s, 0, c
        );
    
        return mul(rotationMatrix, vec);
    }
    
    float3 RotateZ(float3 vec, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
    
        float3x3 rotationMatrix = float3x3(
             c, s, 0,
            -s, c, 0,
             0, 0, 1
        );
    
        return mul(rotationMatrix, vec);
    }
    
    void GetBezierPoints(float2 p1_xz, float2 p2_xz, float4 angular_disp, out float3 p1, out float3 p2)
    {
        //angular_disp.y = angular_disp.y > 0 ? 0 : angular_disp.y;
        p1 = RotateY(float3(p1_xz.x, 0, p1_xz.y), angular_disp.y);
        p2 = RotateY(float3(p2_xz.x, 0, p2_xz.y), angular_disp.y);
        
        
        float3 p1p2 = RotateY(p2 - p1, angular_disp.w);
        p2 = p1 + p1p2;
        
        p1 = RotateZ(p1, angular_disp.z);
        p2 = RotateZ(p2, angular_disp.z);
        
    }
    
    float GetAngularAcc(
        float wind_coff,
        float damping_coff,
        float stiffness,
        float mass,
        float edge_length,
        float3 wind,
        float3 normal_dir,
        float angular_velocity,
        float angular_disp
    )
    {
        float wind_force = wind_coff * dot(wind, normal_dir);
        float damping_force = -damping_coff * angular_velocity;
        
        float positive_angular_disp = angular_disp < 0 ? 2 * PI_VALUE + angular_disp : angular_disp;
        float restore_force = -stiffness * abs(angular_disp) * cos(positive_angular_disp / 2.0);
        
        return (wind_force + damping_force + restore_force) / (edge_length * mass);
    }
    
    float simpleFunc(float value)
    {
        return value * 2;
    }

    
    void GrassUpdate(
        float damping_coff,
        float wind_coff,
        float stiffness,
        float mass,
        float time_delta,
        float3 wind,
        float2 p1_xz,
        float2 p2_xz,
        inout float4 angular_velocity,
        inout float4 angular_disp
    )
    {
        float swing_threshold = PI_VALUE * 0.98;
        float p1_threshold_low = PI_VALUE * 0.02;
        float p1_threshold_high = PI_VALUE * 1.98;
        float p1p2_threshold = PI_VALUE * 0.02;
        
        
        if (p1_xz.x < 0)
        {
            p1_xz.x = 0.01;
        }
        float p1_static_bending = atan(p1_xz.y / p1_xz.x);
        
        float2 p1p2_xz = p2_xz - p1_xz;
        float p1p2_static_bending = acos(dot(-p1_xz, p1p2_xz) / (length(p1_xz) * length(p1p2_xz)));

        float3 p1 = float3(0, 0, 0);
        float3 p2 = float3(0, 0, 0);
        GetBezierPoints(p1_xz, p2_xz, angular_disp, p1, p2);
        float3 p1p2 = p2 - p1;
        
        
        float3 wind_force = wind;
        float swing_abs = abs(angular_disp.z);
        if (swing_abs > swing_threshold)
        {
            //wind_force = float3(0, 0, 0);
        }
        
        float3 w_dir = RotateZ(float3(0, -1, 0), angular_disp.z);
        
        float swing_acc = GetAngularAcc(
            wind_coff,
            damping_coff,
            stiffness,
            mass,
            length(p2.xy),
            wind_force,
            w_dir,
            angular_velocity.z,
            angular_disp.z
        );
        
        
        wind_force = wind;
        float total_p1_bend = ShiftSingleAngle(PI_VALUE / 2.0 + angular_disp.y);

        if (total_p1_bend < p1_threshold_low || total_p1_bend > p1_threshold_high)
        {
            //wind_force = float3(0, 0, 0);
        }

        float3 n_dir = cross(w_dir, p1);
        float vec_length = length(n_dir);
        n_dir = vec_length > 0 ? n_dir / vec_length : n_dir;
        
        float p1_length = length(p1);
        float p1p2_length = length(p1p2);
        
        float legnth_sum = p1_length + p1p2_length;
        float p1_mass = mass * p1_length / legnth_sum;
        float p1p2_mass = mass * p1p2_length / legnth_sum;
        
        float p1_bending_acc = GetAngularAcc(
            wind_coff,
            damping_coff,
            stiffness,
            p1_mass,
            p1_length,
            wind_force,
            n_dir,
            angular_velocity.y,
            angular_disp.y
        );
        
        wind_force = wind;
        float total_p1p2_bend = ShiftSingleAngle(p1p2_static_bending + angular_disp.w);
        
        if (abs(total_p1p2_bend) < p1p2_threshold)
        {
            //wind_force = float3(0, 0, 0);
        }
        

        n_dir = cross(w_dir, p1p2);
        vec_length = length(n_dir);
        n_dir = vec_length > 0 ? n_dir / vec_length : n_dir;
        
        
        float p1p2_bending_acc = GetAngularAcc(
            wind_coff,
            damping_coff,
            stiffness,
            p1p2_mass,
            p1p2_length,
            wind,
            n_dir,
            angular_velocity.w,
            angular_disp.w
        );
        
        float4 velocity_delta = float4(0, p1_bending_acc, swing_acc, p1p2_bending_acc) * time_delta;
        
        //float4 velocity_delta = float4(0, 0.5, 0.5, 0) * time_delta;
        
        angular_velocity += velocity_delta;

        angular_disp += angular_velocity * time_delta;
        angular_disp = ShiftAngleVector(angular_disp);
        
    }
};
  