

struct GrassShaderFunctions
{
    
    float GetAngle(float2 vec)
    {
        float2 normalizedVector = normalize(vec);
    
        float angle = acos(normalizedVector.x);
 
        if (normalizedVector.y < 0)
        {
            angle = -angle;
        }
    
        return angle;
    }

    float3 RotateZ(float3 vec, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
    
        float3x3 rotationMatrix = float3x3(
             c, -s, 0,
             s, c, 0,
             0, 0, 1
        );
    
        return mul(rotationMatrix, vec);
    }
    
    float3 GrassPosOffsetAndNormal(
        in float2 uv, float4 p1, float4 p2, float scale, float width, float base,
        float tilt,
        float mid_smooth, float rim_pos, float rim_smooth, float y_strength, out float3 normal
    )
    {
        float vec_length_threshold = 0.00001;
        float t = uv.x;
        float g = uv.y;

        float s = 1 - t;
        float s2 = s * s;
        float t2 = t * t;

        float g_axis_val = g - 0.5;
        
        // initialize points at static positions
        p1.w = p1.w > 1 ? 1 : p1.w;
        p2.w = p1.w < p2.w ? p1.w : p2.w;
        float4 p0 = float4(0, 0, 0, 1);
        
        float4 curve = s2 * p0 + 2 * s * t * p1 + t2 * p2;
        float3 curve_tangent = 2 * s * (p1.xyz) + 2 * t * (p2.xyz - p1.xyz);
        
        float2 p0_xy_norm = float2(0, 1);
        float2 p1_xy_norm = float2(-p1.y, p1.x);
        float vec_length = length(p1_xy_norm);
        p1_xy_norm = vec_length < vec_length_threshold ? p0_xy_norm : p1_xy_norm / vec_length;
        
        float2 p1p2 = p2.xy - p1.xy;
        float2 p2_xy_norm = float2(-p1p2.y, p1p2.x);
        vec_length = length(p2_xy_norm);
        p2_xy_norm = vec_length < vec_length_threshold ? p1_xy_norm : p2_xy_norm / vec_length;
        
        float xy_norm_angle = s2 * GetAngle(p0_xy_norm) + 2 * s * t * GetAngle(p1_xy_norm) + t2 * GetAngle(p2_xy_norm);
        
        float3 xy_norm = float3(cos(xy_norm_angle), sin(xy_norm_angle), 0);
        
        
        /* tilt xy_plane norm abount the curve tangent */
        vec_length = length(curve_tangent);
        float3 unit_tangent = (vec_length > vec_length_threshold) ? (curve_tangent / vec_length) : curve_tangent;

        float tilt_amount = p2.w / curve.w * tilt;
        
        // float tilt_amount = tilt;

        float tilt_cos = cos(tilt_amount);
        float tilt_sin = sin(tilt_amount);
        xy_norm = xy_norm * tilt_cos + cross(unit_tangent, xy_norm) * tilt_sin;

    
        /* get position offset */
        // scale the curve and subtract the x, y value of the original rectangle rectangle mesh 
        
        float3 pos_offset = scale * (curve.xyz + g_axis_val * s * (t + base) * width * xy_norm - float3(t, g_axis_val, 0));
        
        //float3 pos_offset = scale * (curve.xyz + g_axis_val * xy_norm - float3(t, g_axis_val, 0));
    
    
        /* get normal */
        float3 curve_norm = cross(curve_tangent, xy_norm);

        float smoothing_value = saturate((g_axis_val + mid_smooth) / (mid_smooth * 2));
        float middle_value = smoothing_value * smoothing_value * (3.0 - 2.0 * smoothing_value);

        float rim_smoothing_value = saturate((abs(g_axis_val) - rim_pos + rim_smooth) / (rim_smooth * 2));
        float rim_value = rim_smoothing_value * rim_smoothing_value * (3.0 - 2.0 * rim_smoothing_value);

        float linear_value = (1.0 - middle_value) * rim_value + middle_value * (1.0 - rim_value);

        float y = (1 - 2 * linear_value) * y_strength;
        float3 normal_vector = curve_norm + y * xy_norm;
        vec_length = length(normal_vector);

        normal = (vec_length > vec_length_threshold) ? (normal_vector / vec_length) : normal_vector;
    
        return pos_offset;
    }
};


    
