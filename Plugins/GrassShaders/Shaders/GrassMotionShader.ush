#define PI_VALUE 3.14159265358979323846

#define ROD_ALIGMENT_THRESHOLD 0.0001

// Rotation uses left hand rule. When the rotating axis is facing toward you, positive angle is clockwise

struct GrassMotionShaderFunctions
{
    float ShiftToPIAtMaxAngle(float angle)
    {
        angle = fmod(angle, 2.0 * PI_VALUE);

        if (angle > PI_VALUE)
        {
            angle -= 2.0 * PI_VALUE;
        }
        else if (angle < -PI_VALUE)
        {
            angle += 2.0 * PI_VALUE;
        }

        return angle;
    }

    float ShiftToPositiveAngle(float angle)
    {
        angle = fmod(angle, 2.0 * PI_VALUE);

        if (angle < 0)
        {
            angle += 2.0 * PI_VALUE;
        }

        return angle;
    }

    float3 RotateY(float3 vec, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
    
        float3x3 rotationMatrix = float3x3(
            c, 0, s,
            0, 1, 0,
            -s, 0, c
        );
    
        return mul(rotationMatrix, vec);
    }
    
    float3 RotateZ(float3 vec, float angle)
    {
        float s = sin(angle);
        float c = cos(angle);
    
        float3x3 rotationMatrix = float3x3(
             c, -s, 0,
             s, c, 0,
             0, 0, 1
        );
    
        return mul(rotationMatrix, vec);
    }
    
    void GetBezierPoints(float2 p1_xz, float2 p2_xz, float4 angular_disp, out float3 p1, out float3 p2)
    {
        //angular_disp.y = angular_disp.y > 0 ? 0 : angular_disp.y;
        p1 = RotateY(float3(p1_xz.x, 0, p1_xz.y), angular_disp.y);
        p2 = RotateY(float3(p2_xz.x, 0, p2_xz.y), angular_disp.y);
        
        
        float3 p1p2 = RotateY(p2 - p1, angular_disp.w);
        p2 = p1 + p1p2;
        
        p1 = RotateZ(p1, angular_disp.z);
        p2 = RotateZ(p2, angular_disp.z);
        
    }
    
    float IntegrateOneOverQuad(float b, float c, float x)
    {
        float denom = sqrt(4 * c - b * b);
        return 2 / denom * (atan((2 * x + b) / denom) - atan(b / denom));

    }
    
    /*
    float IntegrateXOverQuad(float b, float c, float x)
    {
        return 0.5 * (log(x * x + b * x + c) - log(c)) - b / 2.0 * IntegrateOneOverQuad(b, c, x);
    }
    float IntegrateX2OverQuad(float b, float c, float x)
    {
        return x - b * IntegrateXOverQuad(b, c, x) - c * IntegrateOneOverQuad(b, c, x);
    }
    
    float IntegrateX3OverQuad(float b, float c, float x)
    {
        return x * x / 2.0 - b * IntegrateX2OverQuad(b, c, x) - c * IntegrateXOverQuad(b, c, x);
    }
    */
    
    float GetSecondRodTorque(
        float r2_stiffness,
        float damping_coefficient,
        float angular_velocity,
        float angular_displacement,
        float3 r1_end, 
        float3 r2_end, 
        float3 wind_force,
        float3 rotational_axis,
        float3 r2_rotational_axis,
    )
    {   
        float3 r2_dir = r2_end - r1_end;
        float r2_length = length(r2_dir);
        
        
        float3 r2_torque_force_dir = cross(r2_rotational_axis, r2_dir);
        
        r2_torque_force_dir = r2_torque_force_dir / length(r2_torque_force_dir);
        // to make total damping force and restore force acting on the rod equal to 
        // r2_stiffness * angular_velocity and  damping_coefficient * angular_velocity respectivley
        // the force acting on the per length of 1 must be set to the total force * 2 / rod length
        float3 force = wind_force - 2 * (r2_stiffness * angular_velocity + damping_coefficient * angular_velocity)/(r2_length) * r2_torque_force_dir;
        
        rotational_axis = rotational_axis / length(rotational_axis);
        
        float3 axis_c_r1 = cross(rotational_axis, r1_end);
        float3 axis_c_r2_dir = cross(rotational_axis, r2_dir);
        
        float l0_torque_dir_term = dot(cross(r1_end, axis_c_r1), rotational_axis);
        float l1_torque_dir_term = dot(cross(r1_end, axis_c_r2_dir) + cross(r2_dir, axis_c_r1), rotational_axis);
        float l2_torque_dir_term = dot(cross(r2_dir, axis_c_r2_dir), rotational_axis);
        
        float l0_force_term = dot(force, axis_c_r1);
        float l1_force_term = dot(force, axis_c_r2_dir);
        
        float l0_term = l0_force_term * l0_torque_dir_term;
        float l1_term = l0_force_term * l1_torque_dir_term + l1_force_term * l0_torque_dir_term;
        float l2_term = l0_force_term * l2_torque_dir_term + l1_force_term * l1_torque_dir_term;
        float l3_term = l1_force_term * l2_torque_dir_term;
        
        float quad_b = 2 * dot(r2_dir, r1_end);
        float quad_c = length(r1_end);
        quad_c = quad_c * quad_c;
        float r2_length_square = r2_length * r2_length;
        
        float l0_intergral = IntegrateOneOverQuad(quad_b, quad_c, r2_length);
        float l1_integral = 0.5 * (log(r2_length_square + quad_b * r2_length + quad_c) - log(quad_c)) - quad_b / 2.0 * l0_intergral;
        float l2_integral = r2_length - quad_b * l1_integral - quad_c * l0_intergral;
        float l3_integral = r2_length_square / 2.0 - quad_b * l2_integral - quad_c * l1_integral;
        
        return l0_term * l0_intergral + l1_term * l1_integral + l2_term * l2_integral + l3_term * l3_integral;

    }
    
    float GetSingleRodTorque(
        float damping_coff,
        float stiffness,
        float3 wind_force,
        float3 rod_start,
        float3 rod_end,
        float3 rotational_axis,
        float angular_velocity,
        float angular_disp,
    )
    {
        // dot(rod_start, rod_end) must be equal to 1 in this function
        
        float3 rod = rod_end - rod_start;
        float rod_length = length(rod);
        float3 rod_dir = rod / rod_length;
        
        float3 rotating_dir = cross(rotational_axis, rod_start);
        float vec_length = length(rotating_dir);
        rotating_dir = vec_length > 0 ? rotating_dir / vec_length : rotating_dir;
        
        rotational_axis = rotational_axis / length(rotational_axis);       
        
        
        
        // forces acting on per length of 1
        float projected_wind_force = dot(wind_force, rotating_dir) * dot(cross(rod_dir, rotating_dir), rotational_axis);
        float damping_force = -2 * damping_coff * angular_velocity / rod_length;
        float restore_force = -2 * stiffness * angular_disp / rod_length;
   
        float start_length = length(rod_start);
        float end_length = length(rod_end);
        return (projected_wind_force + damping_force + restore_force) * (rod_end * rod_end - rod_start - rod_start) / 2.0;
       
    }
    
    float GetMomentOfInertia(float mass, float3 r1_end, float3 r2_end)
    {
        float3 r2 = r2_end - r1_end;
        float r2_length = length(r2);
        float r1_length = length(r1_end);
        float3 r2_center_distance = length(r2 / 2 + r1_end);
        
        float r2_mass = mass * r2_length / (r1_length + r2_length);
        
        // Moment of Inertia caused by R2 rod
        // = Moment of Inertia of R2 at its center of mass + (R2 center of mass distance from the pivot)^2
        //
        // Moment of Inertia of R2 at its center of mass = r2_mass * r2_length * r2_length / 12.0
        float r2_MI = r2_mass * (r2_length * r2_length / 12.0 + r2_center_distance * r2_center_distance);
        
        float r1_MI = (mass - r2_mass) / 3.0 * r1_length * r1_length;
        
        return r1_MI + r2_MI;
    
    }
    
    float GetAngularAcc(
        float wind_coff,
        float damping_coff,
        float stiffness,
        float mass,
        float3 wind,
        float3 edge,
        float3 rotating_dir,
        float3 axis_dir,
        float angular_velocity,
        float angular_disp,
        out float3 debug_wind_force
    )
    {
        float edge_length = length(edge);
        float3 edge_dir = edge_length > 0 ? edge / edge_length : edge;
        
        float vec_length = length(rotating_dir);
        rotating_dir = vec_length > 0 ? rotating_dir / vec_length : rotating_dir;
        
        vec_length = length(axis_dir);
        axis_dir = vec_length > 0 ? axis_dir / vec_length : axis_dir;
               
        // actually bellow variables with torque in the names are actually torque divided by edge length
        float damping_torque = -damping_coff * angular_velocity;
        float restore_torque = (angular_disp > 0 ? -1 : 1) * abs(stiffness * angular_disp);
        //float wind_torque = wind_coff * dot(wind, rotating_dir) * abs(cross(axis_dir, edge_dir));
        
        float wind_torque = wind_coff * dot(wind, rotating_dir) * dot(cross(edge_dir, rotating_dir), axis_dir);
        
        if (wind_torque < 0)
        {
            debug_wind_force = -edge * 10;
        }
        else
        {
            debug_wind_force = edge * 10;
        }
        
        debug_wind_force = float3(wind_torque, restore_torque, 0);
        
        
        return (wind_torque + damping_torque + restore_torque) / (edge_length * mass);
    }
    
    float GetFirstPivotAngularAcc(
        float wind_coff,
        float damping_coff,
        float stiffness,
        float r2_stiffness,
        float mass,
        float3 wind,
        float3 r1_end,
        float3 r2_end,
        float3 rotational_axis,
        float3 r2_rotational_axis,
        float angular_velocity,
        float angular_disp,
        float r2_angular_velocity,
        float r2_angular_disp,
    )
    {
        float inertia = GetMomentOfInertia(mass, r1_end, r2_end);
        
        float r1_length = length(r1_end);
        float r2 = r2_end - r1_end;
        float r2_length = length(r2_end);
        
        float r1_r2_dot = dot(r1_end / r1_length, r2 / r1_length);
        
        float r2_torque = (abs(r1_r2_dot) + ROD_ALIGMENT_THRESHOLD >= 1.0) ? GetSingleRodTorque(
                damping_coff,
                stiffness,
                wind_coff * wind,
                r1_end,
                r2_end,
                rotational_axis,
                angular_velocity,
                angular_disp
            ) : GetSecondRodTorque(
                r2_stiffness,
                damping_coff,
                r2_angular_velocity,
                r2_angular_disp,
                r1_end,
                r2_end,
                wind_coff * wind,
                rotational_axis,
                r2_rotational_axis
            );
        
        float r1_torque = GetSingleRodTorque(
            damping_coff,
            stiffness,
            wind_coff * wind,
            float3(0,0,0),
            r1_end,
            rotational_axis,
            angular_velocity,
            angular_disp
        );
        
        return (r1_torque + r2_torque) / inertia;
    }
    
    void GrassUpdate(
        float damping_coff,
        float swing_damping_coff,
        float wind_coff,
        float stiffness,
        float swing_stiffness,
        float mass,
        float time_delta,
        float3 wind,
        float2 p1_xz,
        float2 p2_xz,
        inout float4 angular_velocity,
        inout float4 angular_disp,
        out float3 wind_z_force
    )
    {
        float swing_threshold = PI_VALUE * 0.98;
        float p1_threshold_low = PI_VALUE * 0.02;
        float p1_threshold_high = PI_VALUE * 1.98;
        float p1p2_threshold = PI_VALUE * 0.02;
        
        
        if (p1_xz.x < 0)
        {
            p1_xz.x = 0.01;
        }
        float p1_static_bending = atan(p1_xz.y / p1_xz.x);
        
        float2 p1p2_xz = p2_xz - p1_xz;
        float p1p2_static_bending = acos(dot(-p1_xz, p1p2_xz) / (length(p1_xz) * length(p1p2_xz)));

        float3 p1 = float3(0, 0, 0);
        float3 p2 = float3(0, 0, 0);
        GetBezierPoints(p1_xz, p2_xz, angular_disp, p1, p2);
        float3 p1p2 = p2 - p1;
        
        
        float3 wind_force = wind;
        float swing_abs = abs(angular_disp.z);
        if (swing_abs > swing_threshold)
        {
            //wind_force = float3(0, 0, 0);
        }
        
        float3 swing_rotating_dir = RotateZ(float3(0, 1, 0), angular_disp.z);
        
        float swing_acc = GetAngularAcc(
            wind_coff,
            swing_damping_coff,
            swing_stiffness,
            mass,
            wind_force,
            p2,
            swing_rotating_dir,
            float3(0, 0, 1),
            angular_velocity.z,
            angular_disp.z,
            wind_z_force
        );
        
        
        wind_force = wind;
        float total_p1_bend = ShiftToPIAtMaxAngle(PI_VALUE / 2.0 + angular_disp.y);

        if (total_p1_bend < p1_threshold_low || total_p1_bend > p1_threshold_high)
        {
            //wind_force = float3(0, 0, 0);
        }

        float3 rotating_dir = cross(swing_rotating_dir, p1);
        
        float p1_length = length(p1);
        float p1p2_length = length(p1p2);
        
        float legnth_sum = p1_length + p1p2_length;
        float p1_mass = mass * p1_length / legnth_sum;
        float p1p2_mass = mass * p1p2_length / legnth_sum;
        
        float3 temp_val;
        float p1_bending_acc = GetAngularAcc(
            wind_coff,
            damping_coff,
            stiffness,
            p1_mass,
            wind_force,
            p1,
            rotating_dir,
            swing_rotating_dir,
            angular_velocity.y,
            angular_disp.y,
            temp_val
        );
        
        wind_force = wind;
        float total_p1p2_bend = ShiftToPIAtMaxAngle(p1p2_static_bending + angular_disp.w);
        
        if (abs(total_p1p2_bend) < p1p2_threshold)
        {
            //wind_force = float3(0, 0, 0);
        }
        

        rotating_dir = cross(swing_rotating_dir, p1p2);
        
        
        float p1p2_bending_acc = GetAngularAcc(
            wind_coff,
            damping_coff,
            stiffness * 0.8,
            p1p2_mass,
            wind_force,
            p1p2,
            rotating_dir,
            swing_rotating_dir,
            angular_velocity.w,
            angular_disp.w,
            temp_val
        );
        
        
        float4 velocity_delta = float4(0, p1_bending_acc, swing_acc, p1p2_bending_acc) * time_delta;
        
        //float4 velocity_delta = float4(0, 0.5, 0.5, 0) * time_delta;
        
        angular_velocity += velocity_delta;

        angular_disp += angular_velocity * time_delta;
        //angular_disp = fmod(angular_disp, 8 * PI_VALUE);
        
    }
};
  