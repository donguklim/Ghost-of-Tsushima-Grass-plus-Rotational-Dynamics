#ifndef __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__
#define __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__

#include "Common/Constants.ush"
#include "Common/BezierCurve.ush"

#define P1_ANGLE_THRESHOLD 0.2
#define COLLISION_COEFFICENT_TRHESHOLD 0.01


void GetCollidingAngleDelta(in float3 barDir, in float3 normal, inout float4 angularDispDelta, inout float4 angularVelocity)
{
    float deltaAngle = length(angularDispDelta.xyz);
    if (deltaAngle < 0.05)
    {
        return;
    }
        
    float3 axis = angularDispDelta.xyz / deltaAngle;
    float3 axisXBar = cross(axis, barDir);
        
    float aVal = dot(axisXBar, normal);
    float bVal = -dot(cross(axis, axisXBar), normal);
    float cVal = dot(barDir, normal) - bVal - BAR_DOT_GROUND_THRESHOLD;
    
/*
    dot(ground_norm, new bar direction)
        = a * sin(angle delta) + b * cos(angle delta) - b + dot(current bar direction, normal)
    
    dot(ground_norm, new bar direction) - BAR_DOT_GROUND_THRESHOLD  =  a * sin(x) + b * cos(x) + c,
    where c = dot(current bar direction, normal) - b - BAR_DOT_GROUND_THRESHOLD
    
    f(x) = a * sin(x) + b * cos(x) + c
      
    we want to increase x from 0 to the point where f(x) is not positive anymore.
    
    df/dx(x) = a * cos(x) - b * sin(x)
    the critical values of x where df/dx(x) = 0 is 
        
        atan(a/b)
    
    two critical values exist since tan(x) == tan(x + pi)
    
    f maximum is c + a^2 + b^2
    f minimum is c - (a^2 + b^2)
    
*/
    // f(0) = c + a * sin(0) + b * cos(0) = c + b
    // already has collided at x = 0
    if (cVal + bVal < COLLISION_COEFFICENT_TRHESHOLD)
    {
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = float3(0, 0, 0);
        return;
    }
    
    float absA = abs(aVal);
    float absB = abs(bVal);
    float absC = abs(cVal);
    
    // decreasing angle does not have any effect on ground norm dot value
    if (absA < COLLISION_COEFFICENT_TRHESHOLD && absB < COLLISION_COEFFICENT_TRHESHOLD)
    {
        return;
    }
    
    // f(x) = b * cos(x)
    if (absC < COLLISION_COEFFICENT_TRHESHOLD && absA < COLLISION_COEFFICENT_TRHESHOLD)
    {
        float angleMax = bVal < 0.0f ? 0.0f : 0.5 * PI_VALUE;
        
        if (deltaAngle < angleMax)
        {
            return;
        }
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = axis * angleMax;
        return;
    }
    
    // f(x) = a * sin(x)
    if (absC < COLLISION_COEFFICENT_TRHESHOLD && absB < COLLISION_COEFFICENT_TRHESHOLD)
    {
        float angleMax = aVal < 0.0f ? 0.0f : PI_VALUE;
        
        if (deltaAngle < angleMax)
        {
            return;
        }
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = axis * angleMax;
        return;
    }
    
    
    // f(x) = a * sin(x) + b * cos(x)
    if (absC < COLLISION_COEFFICENT_TRHESHOLD)
    {
        float zeroX = atan(-bVal / aVal);
        zeroX = zeroX < 0.0f ? zeroX + PI_VALUE : zeroX;
        
        if (zeroX < deltaAngle)
        {
            return;
        }
        
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = zeroX * axis;
        return;
    }
    
    // transform f(x) to f(x) = a * sin(x) + b * cos(x) + 1
    // scale does not matter since we want to find value of x where f(x) begins to become negaitve
    
    
    aVal /= cVal;
    bVal /= cVal;
    
     // f(x) = 1 + b * cos(x), 
    if (absA < COLLISION_COEFFICENT_TRHESHOLD)
    {
        float cosVal = -1.0 / bVal;
        // no colliding at any angle
        if (1.0 - abs(cosVal) < COLLISION_COEFFICENT_TRHESHOLD)
        {
            return;
        }
       
        
        float allowedAngleMax = acos(cosVal);
        if (deltaAngle <= allowedAngleMax)
        {
            return;
        }
        
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = allowedAngleMax * axis;
        return;
    }
    
    //  f(x) = 1 + a * sin(x)
    if (absB < COLLISION_COEFFICENT_TRHESHOLD)
    {
        float sinVal = -1.0f / aVal;
        if (1.0 - abs(sinVal) < COLLISION_COEFFICENT_TRHESHOLD)
        {
            return;
        }
        
        float allowedAngleMax = asin(sinVal);
        
        allowedAngleMax = allowedAngleMax < 0.0f ? PI_VALUE - allowedAngleMax : allowedAngleMax;
        
        if (deltaAngle < allowedAngleMax)
        {
            return;
        }
        
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = allowedAngleMax * axis;
        return;
    }
    
    float maginitude = sqrt(aVal * aVal + bVal * bVal);
    
    // no colliding at any angle
    if (maginitude - 1.0 < COLLISION_COEFFICENT_TRHESHOLD)
    {
        return;
    }
    
    /*
        Given a * sin(x) + b * cos(x) = 1
        using trigonometric identity sin(i + j) = sin(i)cos(j) = cos(i)sin(j)
        R * sin(x + z) = 1,  where tan(z) = b/a and R = sqrt(a^2 + b^2)
        x = asin(1/R) + atan(b/a)
    */
    
    float asinVal = asin(1.0 / maginitude);
    float atanVal = atan(bVal / aVal);
    
    /*
        sin(t) = sin(pi - t)
        tan(a) = tan(a + pi)
        need to compare all cases
    
        a + t
        a  + pi - t
        a + pi + t
        a + pi + pi - t = a - t
    */
    float angleSum = asinVal + atanVal;
    float angleSumPlusPi = angleSum + PI_VALUE;
    float angleDiff = atanVal - asinVal;
    float angleDiffPlusPi = angleDiff + PI_VALUE;
    
    angleSum = angleSum < 0.0f ? angleSum + 2 * PI_VALUE : angleSum;
    angleDiff = angleDiff < 0.0f ? angleDiff + 2 * PI_VALUE : angleDiff;
    angleSumPlusPi = angleSumPlusPi < 0.0f ? angleSumPlusPi + 2 * PI_VALUE : angleSumPlusPi;
    angleDiffPlusPi = angleDiffPlusPi < 0.0f ? angleDiffPlusPi + 2 * PI_VALUE : angleDiffPlusPi;
    
    float zeroX = min(min(angleDiff, angleSum), min(angleSumPlusPi, angleDiffPlusPi));
    
    if (deltaAngle < zeroX)
    {
        return;
    }
    
    angularVelocity.xyz = float3(0, 0, 0);
    angularDispDelta.xyz = zeroX * axis;

}

void GetMaximumUpwardDelta(float3 barDir, float3 normal, inout float4 angularDispDelta, inout float4 angularVelocity)
{
    float deltaAngle = length(angularDispDelta.xyz);
    if (deltaAngle < 0.05)
    {
        return;
    }
        
    float3 axis = angularDispDelta.xyz / deltaAngle;
    float3 axisXBar = cross(axis, barDir);
        
    float aVal = dot(axisXBar, normal);
    float bVal = dot(cross(axis, axisXBar), normal);
    
    float absA = abs(aVal);
    float absB = abs(bVal);
    
/*
    dot(ground_norm, new bar direction)
        = a * sin(angle delta) - b * cos(angle delta) + b + dot(current bar direction, normal)
    
    f(x) =  a * sin(x) - b * cos(x) + c
    df/dx(x) = a * cos(x) + b * sin(x)
    
     we want to increase x from 0 to the point where df/dx is not positive anymore.
    
    if df/dx(0) < 0
    return zero vector
    Else find x for df/dx(x) == 0
    x = atan(-a/b)
 */
    
    // angular displacement delta does not increase nor decrease the dot value.
    if (absA < COLLISION_COEFFICENT_TRHESHOLD && absB < COLLISION_COEFFICENT_TRHESHOLD)
    {
        return;
    }
    
    //  df/dx(0) = a
    // already negative derievative
    if (aVal < 0.0f)
    {
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = float3(0, 0, 0);
        return;
    }
            
    // df/dx(0) = b * sin(x)
    if (absA < COLLISION_COEFFICENT_TRHESHOLD)
    {
        if (bVal < 0.0f)
        {
            angularVelocity.xyz = float3(0, 0, 0);
            angularDispDelta.xyz = float3(0, 0, 0);
            return;
        }
        
        if (deltaAngle < PI_VALUE)
        {
            return;
        }
        
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = axis * PI_VALUE;
        return;
    }
    
    // df/dx(x) = a * cos(x)
    // a is positive by above df/dx(0) check
    if (absB < COLLISION_COEFFICENT_TRHESHOLD)
    {   
        if (deltaAngle < 0.5 * PI_VALUE)
        {
            return;
        }
        
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = axis * 0.5 * PI_VALUE;
        return;
    }
        
    float xVal = atan(-aVal / bVal);
    xVal = xVal < 0.0f ? xVal + PI_VALUE : xVal;
    
    if (xVal < deltaAngle)
    {
        angularVelocity.xyz = float3(0, 0, 0);
        angularDispDelta.xyz = xVal * axis;
    }

}


float3 GetBar2TorqueOnP0(
    float dampingCoeff,
    float3 windForce,
    float3 bar1AngularVelocity,
    float3 bar1,
    float bar2AngularVelocity,
    float3 bar2RotationalAxis,
    float3 p2
)
{
    float3 bar2 = (p2 - bar1);
    float bar2Length = length(bar2);
    float bar2LengthSquare = bar2Length * bar2Length;
    float3 bar2Dir = bar2 / bar2Length;
    float3 bar2TorqueDir = cross(bar2RotationalAxis, bar2Dir);
        
    float3 l0ForceTerm = windForce - dampingCoeff * cross(bar1AngularVelocity, bar1);
    float3 l1ForceTerm = -dampingCoeff * bar2AngularVelocity * bar2TorqueDir - dampingCoeff * cross(bar1AngularVelocity, bar2Dir);
    float3 l0Term = cross(bar1, l0ForceTerm);
    float3 l1Term = cross(bar2Dir, l0ForceTerm) + cross(bar1, l1ForceTerm);
    float3 l2Term = cross(bar2Dir, l1ForceTerm);
        
    return l0Term * bar2Length + l1Term * bar2LengthSquare / 2.0f + l2Term * bar2Length * bar2LengthSquare / 3.0f;

}
float3 GetPivotBarTorque(
    float dampingCoff,
    float stiffness,
    float3 windForce,
    float3 bar,
    float3 angularVelocity,
    float3 angularDisp
)
{
    float barLength = length(bar);
    return barLength * (
        cross(bar, windForce) / 2.0f
        - dampingCoff / 3.0f * cross(bar, cross(angularVelocity, bar))
    ) - stiffness * angularDisp;
}
    
    
float GetMomentOfInertia(float mass, float3 bar1, float3 p2)
{
    float3 bar2 = p2 - bar1;
    float bar2Length = length(bar2);
    float bar1Length = length(bar1);
    // bar2 center distance from pivot (0, 0, 0)
    float bar2CenterDistance = length(bar2 / 2 + bar1);
    float lengthSum = bar1Length + bar2Length;
        
    float bar2Mass = mass * bar2Length / lengthSum;
    float bar1Mass = mass * bar1Length / lengthSum;
        
    // Moment of Inertia caused by bar 2
    // = Moment of Inertia of bar2 at its center of mass + (bar 2 center of mass distance from the pivot)^2
    //
    // Moment of Inertia of bar 2 at its center of mass = bar2_mass * bar2_length * bar2_length / 12.0
    float bar2MomentOfIntertia = bar2Mass * (bar2Length * bar2Length / 12.0 + bar2CenterDistance * bar2CenterDistance);
        
    float bar1MomentOfIntertia = (bar1Mass) / 3.0 * bar1Length * bar1Length;
        
    return bar1MomentOfIntertia + bar2MomentOfIntertia;
    
}

float Get2DAngle(float2 vec)
{
    float vecLength = length(vec);
    if (vecLength < ANGLE_THRESHOLD)
    {
        return 0.0f;
    }
    
    float2 normalizedVector = vec / vecLength;
    
    float angle = acos(normalizedVector.x);
 
    if (normalizedVector.y > 0)
    {
        angle = -angle;
    }
    
    return angle;
}

 
void GrassUpdate(
    float dampingCoff,
    in float massDensity,
    float stiffness,
    float p2Stiffness,
    in float timeDelta,
    float3 wind,
    in FQuat initialOrientation,
    in float3 scale,
    in float2 p1Position,
    float3 groundNormal,
    inout float4 angularVelocity,
    inout float4 angularDisp
)
{
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float bar2StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);
    float mass = scale.x * scale.y * massDensity < 0.01f ? 1.0f : massDensity;
    
    wind *= scale.y;
    dampingCoff *= scale.y;
    stiffness *= scale.y * scale.x;
    p2Stiffness *= scale.y * scale.x;
    
    float3 staticP1 = float3(p1Position.x, 0, p1Position.y) * scale.x;
    float3 staticP2 = float3(1, 0, 0) * scale.x;
    staticP1 = QuatRotateVector(initialOrientation, staticP1);
    staticP2 = QuatRotateVector(initialOrientation, staticP2);
    float3 bar2RotationalAxis = QuatRotateVector(initialOrientation, float3(0, 1, 0));

    float3 p1 = float3(0, 0, 0);
    float3 p2 = float3(0, 0, 0);
    

    GetRotatedBezierPoints(staticP1, staticP2, bar2RotationalAxis, angularDisp, p1, p2, bar2RotationalAxis);
    
    float3 bar1Dir = normalize(p1);
    if (dot(bar1Dir, groundNormal) < 0.0f)
    {
        wind = float3(0, 0, 0);
    }
             
    // p0 angular acceleration that would occur when p1 pivot is seized(when p0p1 and p1p2 dd not bend at p1 and are stationary)
    
    float momentOfIntertia = GetMomentOfInertia(mass, p1, p2);
    float3 p1SeizedP0AngularAcc = (
        GetPivotBarTorque(
            dampingCoff,
            stiffness,
            wind,
            p1,
            angularVelocity.xyz,
            angularDisp.xyz
        ) + GetBar2TorqueOnP0(
            dampingCoff,
            wind,
            angularVelocity.xyz,
            p1,
            angularVelocity.w,
            bar2RotationalAxis,
            p2
        )
    ) / momentOfIntertia;

    float3 bar2 = p2 - p1;

    float bar1Length = length(p1);
    float bar2Length = length(bar2);
    float bar2LengthSquare = bar2Length * bar2Length;
        
    float totalLength = bar1Length + bar2Length;
    float bar1Mass = mass * bar1Length / totalLength;
    float bar2Mass = mass * bar2Length / totalLength;
        
    // plain p1 acceleration (not anuglar), when p1 is seized.
    // (angular acceleration) x p1 is the tangential acceleration
    // (angular velocity) x (angular velocity x p1) is the centirpetal acceleration
    float3 seizedP1PlainAcc = cross(p1SeizedP0AngularAcc, p1) + cross(angularVelocity.xyz, cross(angularVelocity.xyz, p1));
        
    // Inertia force acting on center of mass point(the mid point) of Bar2 due to movement of P1
    // = -(p1 acceleration) * mass of Bar2

    float3 p1InertiaForceTorque = -0.5f * bar2Mass * cross(bar2, seizedP1PlainAcc);
        
    float3 p1Torque = p1InertiaForceTorque + GetPivotBarTorque(
        dampingCoff,
        p2Stiffness,
        wind,
        bar2,
        angularVelocity.w * bar2RotationalAxis,
        angularDisp.w * bar2RotationalAxis
    );
        
    float p1TorqueMagnitude = dot(bar2RotationalAxis, p1Torque);
        
    // The total torque to P1 required to make P1 seized is -p1BendingTorque.
    // Now payback the torque
    
    float p1Acc = 3 * p1TorqueMagnitude / (bar2Mass * bar2LengthSquare);
    
    /*
        Force acting on the end of bar1(p1) due to P1 torque
        
        F = -cross(bar2RotationalAxis, bar2 / bar2Length) * p1TorqueMagnitude / bar2Length
          = cross(bar2, bar2RotationalAxis) * p1TorqueMagnitude / bar2Length^2
       
        Torque on P0 due to the force
        T = cross(p1, F)
    
        Angualr acceleration on P0 due to T
    
        3 * T / (bar1Mass * bar1Length * bar1Length)
        
    */
    // Get point force acting on bar1 end with P0 as pivot due to the torque acting on bar2.
    // And get the angualr acceleration on bar1 due to the force.
    float p0AccFromP1Torque = 3 * cross(p1, cross(bar2, bar2RotationalAxis)) * p1TorqueMagnitude / (bar2LengthSquare) / (bar1Mass * bar1Length * bar1Length);
    
    float3 p0Acc = p1SeizedP0AngularAcc + p0AccFromP1Torque;
           
    float4 velocityDelta = float4(p0Acc, p1Acc) * timeDelta;
    
    angularVelocity += velocityDelta;
        
    float4 dispDelta = angularVelocity * timeDelta; 

    
    // Limit each x, y, z angular displacement of P0 within [-2 PI, 2 PI]
    // Limit P1 angular displacement such that bar1 does not pass through bar1 
    float maxP2AngleDelta = PI_VALUE - P1_ANGLE_THRESHOLD - (bar2StaticAngle + angularDisp.w);
    float minP2AngleDelta = P1_ANGLE_THRESHOLD - PI_VALUE - (bar2StaticAngle + angularDisp.w);
    float3 maxP0AngleDispDelta = -angularDisp.xyz + 2 * PI_VALUE;
    float3 minP0AngleDispDelta = -angularDisp.xyz - 2 * PI_VALUE;
    
    float4 minAngleDispDelta = float4(minP0AngleDispDelta, minP2AngleDelta);
    float4 maxAngleDispDelta = float4(maxP0AngleDispDelta, maxP2AngleDelta);
    
    maxAngleDispDelta = maxAngleDispDelta < 0 ? 0 : maxAngleDispDelta;
    minAngleDispDelta = minAngleDispDelta > 0 ? 0 : minAngleDispDelta;
    
    float4 isOffLimit = step(dispDelta, maxAngleDispDelta) * step(minAngleDispDelta, dispDelta);
    
    dispDelta = clamp(dispDelta, minAngleDispDelta, maxAngleDispDelta);
    angularVelocity *= isOffLimit;
    
    if (dot(bar1Dir, groundNormal) < BAR_DOT_GROUND_THRESHOLD)
    {
        GetMaximumUpwardDelta(bar1Dir, groundNormal, dispDelta, angularVelocity);
    }
    else
    {
        GetCollidingAngleDelta(bar1Dir, groundNormal, dispDelta, angularVelocity);
    }
    
    angularDisp += dispDelta;
        
}

void VerletGrassUpdate(
    in float dampingCoff,
    float massDensity,
    float stiffness,
    float p2Stiffness,
    in float timeDelta,
    float3 wind,
    in FQuat initialOrientation,
    in float3 scale,
    in float2 p1Position,
    float3 groundNormal,
    inout float4 angularVelocity,
    inout float4 angularDisp
)
{
    float mass = scale.x * scale.y * massDensity < 0.01f ? 1.0f : massDensity;
    
    wind *= scale.y;
    dampingCoff *= scale.y;
    stiffness *= scale.y * scale.x;
    p2Stiffness *= scale.y * scale.x;
    
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float bar2StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);

    
    float3 staticP1 = float3(p1Position.x, 0, p1Position.y) * scale.x;
    float3 staticP2 = float3(1, 0, 0) * scale.x;
    staticP1 = QuatRotateVector(initialOrientation, staticP1);
    staticP2 = QuatRotateVector(initialOrientation, staticP2);
    float3 staticBar2RotationalAxis = QuatRotateVector(initialOrientation, float3(0, 1, 0));

    float3 p1 = float3(0, 0, 0);
    float3 p2 = float3(0, 0, 0);
    float3 bar2RotationalAxis = float3(0, 0, 0);

    GetRotatedBezierPoints(staticP1, staticP2, staticBar2RotationalAxis, angularDisp, p1, p2, bar2RotationalAxis);
    
    float3 bar1Dir = normalize(p1);
    if (dot(bar1Dir, groundNormal) < BAR_DOT_GROUND_THRESHOLD)
    {
        wind = float3(0, 0, 0);
    }
    
    float momentOfIntertia = GetMomentOfInertia(mass, p1, p2);
    
    float3 tempSeizedAcc = (
        GetPivotBarTorque(
            dampingCoff,
            stiffness,
            wind,
            p1,
            angularVelocity.xyz,
            angularDisp.xyz
        ) + GetBar2TorqueOnP0(
            dampingCoff,
            wind,
            angularVelocity.xyz,
            p1,
            angularVelocity.w,
            bar2RotationalAxis,
            p2
        )
    ) / momentOfIntertia;

    float3 tempP0AngularVelocity = angularVelocity.xyz + 0.5 * tempSeizedAcc * timeDelta;
    float3 tempP0AngularDisp = angularDisp.xyz + (tempP0AngularVelocity * timeDelta);
    
    float3 tempP1 = float3(0, 0, 0);
    float3 tempP2 = float3(0, 0, 0);
    float3 tempBar2RotationalAxis = float3(0, 0, 0);
    
    GetRotatedBezierPoints(staticP1, staticP2, staticBar2RotationalAxis, float4(tempP0AngularDisp, angularDisp.w), tempP1, tempP2, tempBar2RotationalAxis);
    
    float3 p1SeizedP0AngularAcc = 0.5 * (
        tempSeizedAcc + (
            GetPivotBarTorque(
                dampingCoff,
                stiffness,
                wind,
                tempP1,
                tempP0AngularVelocity,
                tempP0AngularDisp
            ) + GetBar2TorqueOnP0(
                dampingCoff,
                wind,
                tempP0AngularVelocity,
                tempP1,
                angularVelocity.w,
                tempBar2RotationalAxis,
                tempP2
            )
        ) / momentOfIntertia
    );
    
    float3 bar2 = p2 - p1;
    float bar1Length = length(p1);
    float bar2Length = length(bar2);
        
    float totalLength = bar1Length + bar2Length;
    float bar1Mass = mass * bar1Length / totalLength;
    float bar2Mass = mass * bar2Length / totalLength;
        
    
    float3 seizedP1PlainAcc = cross(p1SeizedP0AngularAcc, p1) + cross(angularVelocity.xyz, cross(angularVelocity.xyz, p1));
    float3 p1InertiaForceTorque = -0.5 * bar2Mass * cross(bar2, seizedP1PlainAcc);
        
    float3 p1Torque = p1InertiaForceTorque + GetPivotBarTorque(
        dampingCoff,
        p2Stiffness,
        wind,
        bar2,
        angularVelocity.w * bar2RotationalAxis,
        angularDisp.w * bar2RotationalAxis
    );
        
    float p1TorqueMagnitude = dot(bar2RotationalAxis, p1Torque);
    
    float p1Acc = p1TorqueMagnitude / (bar2Mass * bar2Length * bar2Length / 3.0);
    float3 p0Acc = p1SeizedP0AngularAcc - p1TorqueMagnitude * bar2RotationalAxis / momentOfIntertia;
    
    float4 tempAcc = float4(p0Acc, p1Acc);
    float4 tempAngularVelocity = angularVelocity + 0.5 * tempAcc * timeDelta;
    float4 tempAngulardisp = angularDisp + tempAngularVelocity * timeDelta;
    
    GetRotatedBezierPoints(staticP1, staticP2, staticBar2RotationalAxis, tempAngulardisp, tempP1, tempP2, tempBar2RotationalAxis);
    
    float tempMomentOfIntertia = GetMomentOfInertia(mass, tempP1, tempP2);
    float3 tempBar2 = tempP2 - tempP1;
    
    seizedP1PlainAcc = cross(p1SeizedP0AngularAcc, tempP1) + cross(tempAngularVelocity.xyz, cross(tempAngularVelocity.xyz, tempP2));
    p1InertiaForceTorque = -0.5 * bar2Mass * cross(tempBar2, seizedP1PlainAcc);
    p1Torque = p1InertiaForceTorque + GetPivotBarTorque(
        dampingCoff,
        p2Stiffness,
        wind,
        tempBar2,
        tempAngularVelocity.w * tempBar2RotationalAxis,
        tempAngulardisp.w * tempBar2RotationalAxis
    );
    
    p1TorqueMagnitude = dot(bar2RotationalAxis, p1Torque);
    
    p1Acc = p1TorqueMagnitude / (bar2Mass * bar2Length * bar2Length / 3.0);
    p0Acc = p1SeizedP0AngularAcc - p1TorqueMagnitude * bar2RotationalAxis / tempMomentOfIntertia;
    
    float4 angularAcc = 0.5 * (tempAcc + float4(p0Acc, p1Acc));
    
    float4 velocityDelta = angularAcc * timeDelta;
    angularVelocity += velocityDelta;
        
    float4 dispDelta = angularVelocity * timeDelta;
    
    float maxP2AngleDelta = PI_VALUE - P1_ANGLE_THRESHOLD - (bar2StaticAngle + angularDisp.w);
    float minP2AngleDelta = P1_ANGLE_THRESHOLD - PI_VALUE - (bar2StaticAngle + angularDisp.w);
    float3 maxP0AngleDispDelta = -angularDisp.xyz + 2 * PI_VALUE;
    float3 minP0AngleDispDelta = -angularDisp.xyz - 2 * PI_VALUE;
    
    float4 minAngleDispDelta = float4(minP0AngleDispDelta, minP2AngleDelta);
    float4 maxAngleDispDelta = float4(maxP0AngleDispDelta, maxP2AngleDelta);
    
    maxAngleDispDelta = maxAngleDispDelta < 0 ? 0 : maxAngleDispDelta;
    minAngleDispDelta = minAngleDispDelta > 0 ? 0 : minAngleDispDelta;
    
    float4 isOffLimit = step(dispDelta, maxAngleDispDelta) * step(minAngleDispDelta, dispDelta);
    
    dispDelta = clamp(dispDelta, minAngleDispDelta, maxAngleDispDelta);
    angularVelocity *= isOffLimit;
    
    if (dot(bar1Dir, groundNormal) < BAR_DOT_GROUND_THRESHOLD)
    {
        GetMaximumUpwardDelta(bar1Dir, groundNormal, dispDelta, angularVelocity);
    }
    else
    {
        GetCollidingAngleDelta(bar1Dir, groundNormal, dispDelta, angularVelocity);
    }
        
    angularDisp += dispDelta;
}


float3 GetWindOnlyDistantBarTorque(
    float3 wind_force,
    float3 bar2_rotational_axis,
    float3 bar1_end,
    float3 bar2_end
)
{
    float3 bar2 = (bar2_end - bar1_end);
    float bar2_length = length(bar2);
    float bar2_length_square = bar2_length * bar2_length;
    float3 bar2_dir = bar2 / bar2_length;
        
    float3 bar2_torque_dir = cross(bar2_rotational_axis, bar2_dir);
        
    float3 l0_force_term = wind_force;
    float3 l0_term = cross(bar1_end, l0_force_term);
    float3 l1_term = cross(bar2_dir, l0_force_term);
  
    return l0_term * bar2_length + l1_term * bar2_length_square / 2.0;

}


float3 GetWindOnlyPivotBarTorque(
    float3 wind_force,
    float3 bar
)
{
    float bar_length = length(bar);
    float3 wind_torque = cross(bar, wind_force) * bar_length / 2.0;  
    return bar_length * cross(bar, wind_force) / 2.0;   
}
    

float4 GetApproximateEquilibriumAngularDisplacement(
    float stiffness,
    float p1Stiffness,
    float3 wind,
    float3 scale,
    float2 p1Position,
    FQuat initialOrientation,
    float3 groundNormal
)
{    
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float p1StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);
    
    float3 p1 = float3(p1Position.x, 0, p1Position.y) * scale.x;
    float3 p2 = float3(1, 0, 0) * scale.x;
    p1 = QuatRotateVector(initialOrientation, p1);
    p2 = QuatRotateVector(initialOrientation, p2);
    
    float3 r2_rotational_axis = QuatRotateVector(initialOrientation, float3(0, 1, 0));
    float3 p1p2 = p2 - p1;

    float3 p0Torque = GetWindOnlyPivotBarTorque(
        wind,
        p1
    ) + GetWindOnlyDistantBarTorque(
        wind,
        r2_rotational_axis,
        p1,
        p2
    );
        
    float p1Torque = dot(GetWindOnlyPivotBarTorque(wind, p1p2), r2_rotational_axis);
        
    float4 angularDisp = float4(p0Torque / stiffness, p1Torque / p1Stiffness);
    
    float3 p1Dir = p1 / length(p1);
    
    float dispAngle = length(angularDisp.xyz);
    FQuat rotation = dispAngle < ANGLE_THRESHOLD ? FQuat(0, 0, 0, 1) : QuatFromAxisAngle(angularDisp.xyz / dispAngle, dispAngle);
    float3 newP1Dir = QuatRotateVector(rotation, p1Dir);
        
    // If the new p1 angle from normal direction is beynond threshold, 
    // and current direction is also within some threshold range
    // Don't move p1, and make velocity zero
    //
    // Else if the new p1 angle will go beyond the threshold
    // but current direction is not within the threhsold range
    // adjust the new angular displacement so that it reaches to the threshold 
    // and make velcity zero.
        
    
    if (dot(newP1Dir, groundNormal) < BAR_DOT_GROUND_THRESHOLD)
    {
        if (abs(dot(p1Dir, groundNormal) - BAR_DOT_GROUND_THRESHOLD) < 0.1)
        {
            angularDisp.xyz = float3(0, 0, 0);
        }
        else
        {
            angularDisp.xyz = GetCollidingAngleDelta(p1Dir, angularDisp.xyz, groundNormal);
        }

    }
    
    
    float maxAngle = PI_VALUE - P1_ANGLE_THRESHOLD - p1StaticAngle;
    float minAngle = P1_ANGLE_THRESHOLD - PI_VALUE - p1StaticAngle;
    
    if (maxAngle < 0)
    {
        maxAngle = 0;
    }
    if (minAngle > 0)
    {
        minAngle = 0;
    }
    
    angularDisp.w = angularDisp.w > maxAngle ? maxAngle : angularDisp.w;
    angularDisp.w = angularDisp.w < minAngle ? minAngle : angularDisp.w;
    
    return angularDisp;
    
}

float3 ApproximateAngularDisp(
    float3 wind,
    float3 bar,
    float stiffness
)
{
    float bar_length = length(bar);
    // return bar_length * cross(bar, wind) / 2.0 / stiffness;
    float wind_magnitude = length(wind);
    
    if (wind_magnitude < 0.0001 || bar_length < 0.0001)
    {
        return float3(0, 0, 0);
    }
    
    float bar_wind_angle_cos = dot(wind, bar) / bar_length / wind_magnitude;
    
    // bar and wind is aligned
    if (1 - abs(bar_wind_angle_cos) < 0.001)
    {
        return float3(0, 0, 0);
    }
    
    float3 bar_c_wind = cross(bar, wind);
    float bar_c_wind_length = length(bar_c_wind);
    
    float3 rotational_axis = bar_c_wind / bar_c_wind_length;
    float wind_bar_angle = acos(bar_wind_angle_cos);
    
    // torque from wind 
    float static_wind_torque = bar_length * bar_c_wind_length / 2.0;
    
    // restoration torque, when the bar is rotated to be aligned with the wind direction
    float3 wind_aligned_restoration_torque = stiffness * wind_bar_angle;
    
    //Linearlly approximate the equilibrium angle
    // find t where (t * wind torque) = (1-t) * (wind aligned restoration torque)
    // t = (wind aligned restoration torque) / (wind torque - wind aligned restoration torque)
    // approximated angle = t * (wind bar angle)
    
    return (static_wind_torque) / (static_wind_torque + wind_aligned_restoration_torque) * wind_bar_angle * rotational_axis;

}
    

float4 GetApproximateAngularDisplacement2(
    float stiffness,
    float p1_stiffness,
    float3 wind,
    float3 scale,
    float2 p1Position,
    FQuat initialOrientation,
    float3 ground_normal
)
{
    
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float p1StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);
    
    float3 p1 = float3(p1Position.x, 0, p1Position.y) * scale.x;
    float3 p2 = float3(1, 0, 0) * scale.x;
    p1 = QuatRotateVector(initialOrientation, p1);
    p2 = QuatRotateVector(initialOrientation, p2);
    
    float3 p0Rotation = ApproximateAngularDisp(wind, p1, stiffness);
    
    // If the new p1 angle from normal direction is beynond threshold, 
    // and current direction is also within some threshold range
    // Don't move p1, and make velocity zero
    //
    // Else if the new p1 angle will go beyond the threshold
    // but current direction is not within the threhsold range
    // adjust the new angular displacement so that it reaches to the threshold 
    // and make velcity zero.
    
    float p0RotAngle = length(p0Rotation);
    FQuat p0Quat = p0RotAngle < ANGLE_THRESHOLD ? FQuat(0, 0, 0, 1) : QuatFromAxisAngle(p0Rotation / p0RotAngle, p0RotAngle);
    float bar1_length = length(p1);
    
    float3 bar1_dir = p1 / bar1_length;
    float3 new_bar1 = QuatRotateVector(p0Quat, p1);
    float3 new_bar1_dir = new_bar1 / bar1_length;
    if (dot(new_bar1_dir, ground_normal) < BAR_DOT_GROUND_THRESHOLD)
    {
        if (abs(dot(bar1_dir, ground_normal) - BAR_DOT_GROUND_THRESHOLD) < 0.1)
        {
            p0Rotation = float3(0, 0, 0);
        }
        else
        {
            p0Rotation = GetCollidingAngleDelta(bar1_dir, p0Rotation, ground_normal);
            p0RotAngle = length(p0Rotation);
            p0Quat = p0RotAngle < ANGLE_THRESHOLD ? FQuat(0, 0, 0, 1) : QuatFromAxisAngle(p0Rotation / p0RotAngle, p0RotAngle);
            p1 = QuatRotateVector(p0Quat, p1);
        }

    }
    else
    {
        p1 = new_bar1;
    }
    
    
    p2 = QuatRotateVector(p0Quat, p2);
  
    float3 bar2 = p2 - p1;
    
    float3 p1_rotational_axis = QuatRotateVector(p0Quat, float3(0, 1, 0));
    float3 bar2_wind = wind - dot(wind, p1_rotational_axis) * p1_rotational_axis;
    
    float p1_rotation = dot(ApproximateAngularDisp(bar2_wind, bar2, p1_stiffness), p1_rotational_axis);
    
    
    float max_angle = PI_VALUE - P1_ANGLE_THRESHOLD - p1StaticAngle;
    float min_angle = P1_ANGLE_THRESHOLD - PI_VALUE - p1StaticAngle;
    
    if (max_angle < 0)
    {
        max_angle = 0;
    }
    if (min_angle > 0)
    {
        min_angle = 0;
    }
    
    p1_rotation = p1_rotation > max_angle ?  max_angle : p1_rotation;
    p1_rotation = p1_rotation < min_angle ? min_angle : p1_rotation;
    
    return float4(p0Rotation, p1_rotation);
    
}

#endif //  __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__
