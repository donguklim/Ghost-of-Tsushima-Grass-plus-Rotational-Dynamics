#ifndef __ROTATIONAL_DYNAMIC_GRASS_GRASS_ATTRIBUTES_HLSL__
#define __ROTATIONAL_DYNAMIC_GRASS_GRASS_ATTRIBUTES_HLSL__


#include "Common/Constants.ush"
#include "Common/Random.ush"
#include "Common/QuaternionRotation.ush"

#define GRAVITY 0.981


float findEquilibriumAngle(float yScale, float barLength, float stiffness)
{
    /*
        we want to find angle of the bar from the gravity force direction where 
            
            gravity force torque = sitffness * angle
            gravity force * (bar1 length)^2/2 * sin(x) = stiffness * x
    
            use tylor series approximation sin(x) = x - x^3/3! + x^5/5!
            (This sin approximation works bad with |x| > 0.5 PI)
    
            then x^2 = 20 +- sqrt(100 + 120 *(2 * stiffness / ( gravity force * bar1 length^2) - 1))
    
            we don't want x^2 > 20 so,
    
            x^2 = 20 - sqrt(100 + 120 *(2 * stiffness / (wolrd scale *  gravity force * bar1 length^2) - 1))
    
            In order to make |x| < 0.5 PI, you should limit the bar length to
            
            barLength^2 < 120 * stiffness / (gravity * (45 + PI^4 - 10 * PI^2))
            barLength^2 < 3.785213642762547 * stiffness / gravity
            
            or if you want to limit the angle to some desired angle x
    
            barLength^2 < 120 * stiffness / (gravity * (45 + 16 * x^4 - 40 * x^2))
    */
    
    float discriminant = 100.0f + 120.0f * (2.0f * stiffness / (GRAVITY * yScale * barLength * barLength) - 1.0f);
    
    // this case means stiffness is not enough to withstand gravity, so grass should just lie down on the ground
    if (discriminant < 0.0f)
    {
        return PI_VALUE / 2.0f;
    }
    
    return sqrt(20.0f - sqrt(discriminant));

}


// 0 < baseAngle + additionalAngle < pi
float findEquilibriumBarLength(float yScale, float additionalAngle, float baseAngle, float stiffness)
{
    
    /*
    solve bar 1 length for 
    
        GRAVITY * yScale * (bar1 length)^2/2 * sin(angle + additional angle) = stiffness * additionalAngle
    */
    
    return sqrt(2 * stiffness * additionalAngle / (sin(additionalAngle + baseAngle) * GRAVITY * yScale));

}


float getClumpPositionRandVal(
    float positionNoiseRatio, 
    inout uint clumpSeed, 
    inout uint positionSeed
)
{
    return clamp(FRand(clumpSeed) * GetNoiseMultiplier(positionSeed, positionNoiseRatio), 0.0, 1.0f);

}

void GetGrassttributes(
    uint clumpSeed,
    in float yScaleMin,
    in float yScaleMax,
    in float xScaleMin,
    in float xScaleMax,
    in float stiffnessMin,
    in float stiffnessMax,
    in float p1StiffnessRatioMin,
    in float p1StiffnessRatioMax,
    in float p2StiffnessRatioMin,
    in float positionNoiseRatio,
    in float3 position,
    in FQuat quatRotation,
    out float3 landNormal,
    out float3 scale,
    out FQuat staticOrientation,
    out float stiffness, 
    out float3 colorNoise,
    out float2 p1Position,
    out float2 pivotStiffnessRatio
)
{
    float clampGrowthDistributionPower = 1.0f / lerp(0.2f, 5.0f, FRand(clumpSeed));
    
    uint positionSeed = ComputeSeedFromPosition(position);
    
    float growth = pow(FRand(positionSeed), 0.25);
    float relativeClumpStifness = lerp(0.05f, 0.98f, FRand(clumpSeed));
    float relativeClumpStiffnessSqaure = relativeClumpStifness * relativeClumpStifness;
    float relativeStiffness = clamp(relativeClumpStifness * GetNoiseMultiplier(positionSeed, positionNoiseRatio), 0.0, 1.0f);
    stiffness = lerp(stiffnessMin, stiffnessMax, relativeStiffness);
    
    // growth is only applied for grass attributes
    relativeStiffness *= growth;
    
    
    // low angle differences with grass clump with low stiffness
    // high angle diffrences with grass clump with high stiffness
    float p0Angle = lerp(
        -PI_VALUE * 0.48, 
        -max(MIN_GRASS_PITCH, 0.4 * PI_VALUE * relativeStiffness), 
        getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed)
    );
    
    float yScale = (yScaleMax - yScaleMin) * relativeClumpStifness * min(
        growth + 0.5 + getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed) * 0.05, 
        1.0
    ) + yScaleMin;
    float bar1Length = findEquilibriumBarLength(yScale, p0Angle, 0.0f, relativeStiffness);
    float bar2Length = bar1Length * lerp(0.7, 0.98, getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed));
    
    scale = float3(
        (bar1Length + bar2Length),
        yScale,
        1.0f
    );
    
    /*
        given v = bar1 + bar2
        
        we want dot(bar1, v) / |v| < |v|, 
    
        Otherwise the projected vector of bar1 on v is longer than v, make grass bending look unnatural.
        Above equation is equlivalent to
    
            -|bar1| / |bar2| <= cos(angle btween bar1 and bar2)
    
    */
    float p1AngleMax = acos(-bar2Length / bar1Length);    
    // p0Angle + p1Angle should not exceed 0.5 PI which is direction toward ground
    p1AngleMax = min(PI_VALUE * 0.48 - p0Angle, p1AngleMax);
    p1AngleMax *= pow((1.0f - relativeClumpStifness), 0.1);
    
    float p1Angle = lerp(min(0.3, p1AngleMax), p1AngleMax, pow(getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed), relativeStiffness));
    
    //p1Angle = p1AngleMax;
    float p1RelativeStiffness = p1Angle <= 0.01 ? relativeStiffness : GRAVITY * bar2Length * sin(p0Angle + p1Angle) / p1Angle;
    
    float p1StiffnessRatio = p1RelativeStiffness / relativeStiffness;
    float p2StiffnessRatio = lerp(
        min(p1StiffnessRatio, p2StiffnessRatioMin), 
        p1StiffnessRatio, 
        getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed)
    );

    // bar1 and bar2 not scaled
    float3 bar1 = float3(bar1Length, 0, 0);
    float3 bar2 = bar2Length * float3(cos(p1Angle), 0, sin(-p1Angle));
    float3 p0p2 = bar1 + bar2;
    float p0P2Length = length(p0p2);
    
    
    bar1 = bar1 /  p0P2Length;
    bar2 = bar2 /  p0P2Length;
    p0p2 = p0p2 / p0P2Length;
    float3 p1Xvec = p0p2 * dot(bar1, p0p2);
    float p1Ypos = length(bar1 - p1Xvec);
    float p1Xpos = length(p1Xvec);
    
    p1Position = float2(
        p1Xpos,
        p1Ypos
    );
    
    // by projecting p2 to (0 ,0, 1), bar1 is rotated with the angle of p0p2 vector.
    float pitch = p0Angle + acos(p0p2.x);
    
    colorNoise = float3(
        lerp(0.0f, 1.0f, getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed)),
        lerp(0.0f, 1.0f, getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed)),
        lerp(0.0f, 1.0f, getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed))
    );
    
    p1StiffnessRatio = clamp(p1StiffnessRatio, p1StiffnessRatioMin, p1StiffnessRatioMax);
    pivotStiffnessRatio = float2(
        clamp(p1StiffnessRatio, p1StiffnessRatioMin, p1StiffnessRatioMax),
        clamp(p2StiffnessRatio, p2StiffnessRatioMin, p1StiffnessRatio)
    );
    
    landNormal = QuatRotateVector(quatRotation, float3(0, 0, 1));
    FQuat landLocalOrientation = QuatMultiply(
        QuatFromAxisAngle(
            float3(0, 0, 1),
            lerp(-PI_VALUE * 0.9, PI_VALUE * 0.9, getClumpPositionRandVal(positionNoiseRatio, clumpSeed, positionSeed))
        ),
        QuatFromAxisAngle(
            float3(0, 1, 0),
            pitch
        )
    );
    staticOrientation = QuatMultiply(quatRotation, landLocalOrientation);
}

#endif // __ROTATIONAL_DYNAMIC_GRASS_GRASS_ATTRIBUTES_HLSL__
