#ifndef __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__
#define __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__

#include "Common/Constants.ush"
#include "Common/BezierCurve.ush"

#define BAR_DOT_GROUND_THRESHOLD 0.3
#define P1_ANGLE_THRESHOLD 0.2


float3 GetCollidingAngleDelta(float3 bar_dir, float3 angular_disp_delta, float3 normal)
{
    float angle = length(angular_disp_delta);
    if (angle < 0.1)
        return float3(0, 0, 0);
        
    float3 rot_axis = angular_disp_delta / angle;
    float3 rot_axis_c_bar = cross(rot_axis, bar_dir);
        
    float a_val = dot(rot_axis_c_bar, normal);
        
    float b_val = dot(cross(rot_axis, rot_axis_c_bar), normal);
        
    // dot(ground_norm, bar_direction after angular displacement delta is applied)
    // = a_val * sin(angle delta) + b_val - b_val * cos(angle delta) + dot(current bar_direction, ground_norm)
        
    // we don't want anbove value to have value less than bar_GROUND_DOT_THRESHOLD
        
    // we  want
    // dot(ground_norm, bar_direction after angular_velocity is applied) > BAR_DOT_GROUND_THRESHOLD
        
    float c_val = BAR_DOT_GROUND_THRESHOLD - dot(bar_dir, normal) - b_val;
        
    // We want to solve x for  a * sin(x) - b * cos(x) = c
                
    float abs_a_val = abs(a_val);
    float abs_b_val = abs(b_val);
        
    // changing magnitude of angular velocity won't significantly lift the rod from the ground
    if (abs_a_val < 0.01 && abs_b_val < 0.01)
    {
        return float3(0, 0, 0);
    }
    // Solve -b * cos(x) = c
    else if (abs_a_val < 0.01)
    {
        return rot_axis * acos(c_val / -b_val);
    }
    // Solve a * sin(x) = c
    else if (abs_b_val < 0.01)
    {
        return rot_axis * asin(c_val / a_val);
    }
        
    // Given a * sin(x) - b * cos(x) = c
    // using trigonometric identity sin(i + j) = sin(i)cos(j) = cos(i)sin(j)
    // R * sin(x + z) = c,  where tan(z) = -b/a and R = sqrt(a^2 + b^2)
    // x = asin(c/R) + z

    return rot_axis * (asin(c_val / sqrt(a_val * a_val + b_val * b_val)) - atan(-b_val / a_val));

}


float3 GetDistantBarTorque(
    float dampingCoeff,
    float3 windForce,
    float bar2AngularVelocity,
    float3 bar2RotationalAxis,
    float3 bar1AngularVelocity,
    float3 bar1,
    float3 p2
)
{
    float3 bar2 = (p2 - bar1);
    float bar2Length = length(bar2);
    float bar2LengthSquare = bar2Length * bar2Length;
    float3 bar2Dir = bar2 / bar2Length;
        
    float3 bar2TorqueDir = cross(bar2RotationalAxis, bar2Dir);
        
    float3 l0ForceTerm = windForce - dampingCoeff * cross(bar1AngularVelocity, bar1);
    float3 l1ForceTerm = -dampingCoeff * bar2AngularVelocity * bar2TorqueDir - dampingCoeff * cross(bar1AngularVelocity, bar2Dir);
    float3 l0Term = cross(bar1, l0ForceTerm);
    float3 l1Term = cross(bar2Dir, l0ForceTerm) + cross(bar1, l1ForceTerm);
    float3 l2Term = cross(bar2Dir, l1ForceTerm);
        
        
    return l0Term * bar2Length + l1Term * bar2LengthSquare / 2.0 + l2Term * bar2Length * bar2LengthSquare / 3.0;

}
float3 GetPivotBarTorque(
    float damping_coff,
    float stiffness,
    float3 windForce,
    float3 bar,
    float3 angularVelocity,
    float3 angularDisp
)
{
    float bar_length = length(bar);
    return bar_length * (cross(bar, windForce) / 2.0 - damping_coff * cross(bar, cross(angularVelocity, bar)) / 3.0) - stiffness * angularDisp;
       
}
    
    
float GetMomentOfInertia(float mass, float3 bar1_end, float3 bar2_end)
{
    float3 bar2 = bar2_end - bar1_end;
    float bar2_length = length(bar2);
    float bar1_length = length(bar1_end);
    float r2_center_distance = length(bar2 / 2 + bar1_end);
        
    float bar2_mass = mass * bar2_length / (bar1_length + bar2_length);
        
    // Moment of Inertia caused by bar 2
    // = Moment of Inertia of bar2 at its center of mass + (bar 2 center of mass distance from the pivot)^2
    //
    // Moment of Inertia of bar 2 at its center of mass = bar2_mass * bar2_length * bar2_length / 12.0
    float bar2_MI = bar2_mass * (bar2_length * bar2_length / 12.0 + r2_center_distance * r2_center_distance);
        
    float bar1_MI = (mass - bar2_mass) / 3.0 * bar1_length * bar1_length;
        
    return bar1_MI + bar2_MI;
    
}

float Get2DAngle(float2 vec)
{
    float vecLength = length(vec);
    if (vecLength < 0.001f)
    {
        return 0.0f;
    }
    
    float2 normalizedVector = vec / vecLength;
    
    float angle = acos(normalizedVector.x);
 
    if (normalizedVector.y > 0)
    {
        angle = -angle;
    }
    
    return angle;
}
 
void GrassUpdate(
    in float dampingCoff,
    in float stiffness,
    in float p2Stiffness,
    in float timeDelta,
    in float3 wind,
    in FQuat initialOrientation,
    in float3 scale,
    in float2 p1Position,
    in float3 groundNormal,
    inout float4 angularVelocity,
    inout float4 angularDisp
)
{
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float bar2StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);
    float mass = scale.x * scale.y;
    
    float3 staticP1 = float3(p1Position.x, 0, p1Position.y) * scale.x;
    float3 staticP2 = float3(1, 0, 0) * scale.x;
    staticP1 = QuatRotateVector(initialOrientation, staticP1);
    staticP2 = QuatRotateVector(initialOrientation, staticP2);

    float3 p1 = float3(0, 0, 0);
    float3 p2 = float3(0, 0, 0);
    float3 bar2RotationalAxis = float3(0, 0, 0);

    GetRotatedBezierPoints(staticP1, staticP2, angularDisp, p1, p2, bar2RotationalAxis);
             
    // p0 angular acceleration that would occur when p1 pivot is seized(when p0p1 and p1p2 dd not bend at p1 and are stationary)
    float3 p1SeizedP0AngularAcc = GetPivotBarTorque(
        dampingCoff,
        stiffness,
        wind,
        p1,
        angularVelocity.xyz,
        angularDisp.xyz
    ) + GetDistantBarTorque(
        dampingCoff,
        wind,
        angularVelocity.w,
        bar2RotationalAxis,
        angularVelocity.xyz,
        p1,
        p2
    ) / GetMomentOfInertia(mass, p1, p2);

    float3 p1p2 = p2 - p1;
    float3 p1Dir = normalize(p1);
    float bar1Length = length(p1);
    float bar2Length = length(p1p2);
        
    float totalLength = bar1Length + bar2Length;
    float bar1Mass = mass * bar1Length / totalLength;
    float bar2Mass = mass * bar2Length / totalLength;
        
    // plain p1 acceleration (not anuglar), when p1 is seized.
    // (angular acceleration) x p1 is the tangential acceleration
    // (angular velocity) x (angular velocity x p1) is the centirpetal acceleration
    float3 seizedP1PlainAcc = cross(p1SeizedP0AngularAcc, p1) + cross(angularVelocity.xyz, cross(angularVelocity.xyz, p1));
        
    // Inertia force acting on center of mass point(the mid point) of P1P2 due to movement of P1
    // = -(p1 acceleration) * mass of P1P2

    float3 p1InertiaForceTorque = cross(p1p2 / 2.0, -seizedP1PlainAcc * bar2Mass);
        
    float3 rawP1Torque = p1InertiaForceTorque + GetPivotBarTorque(
        dampingCoff,
        p2Stiffness,
        wind,
        p1p2,
        angularVelocity.w * bar2RotationalAxis,
        angularDisp.w * bar2RotationalAxis
    );
        
    float p1BendingTorque = dot(bar2RotationalAxis, rawP1Torque);
        
    // The total torque to P1 required to make P1 seized is -p1BendingTorque.
    
    // get bar1 angular accelerataion     
    float bar1AccFromP1Torque = -p1BendingTorque / (bar1Mass * bar1Length * bar1Length / 3.0);
    
    // total acceleration on P1 is bar2 acceleration from p1 torque minus bar1 acceleration from p1 torque
    float p1Acc = p1BendingTorque / (bar2Mass * bar2Length * bar2Length / 3.0) - bar1AccFromP1Torque;
    
    
    // total acceleration on P0 is the seized acceleration plus the bar1 acceleration from p1 torque
    float3 p0Acc = p1SeizedP0AngularAcc + (bar1AccFromP1Torque * bar2RotationalAxis);
        
        
    //float4 velocityDelta = float4(p0Acc, p1Acc) * timeDelta;
    
    float4 velocityDelta = float4(p1SeizedP0AngularAcc, p1Acc) * timeDelta;
    angularVelocity += velocityDelta;
        
    float4 dispDelta = angularVelocity * timeDelta;
        
    float deltaAngle = length(dispDelta);
    FQuat rotation = deltaAngle < ANGLE_THRESHOLD ? FQuat(0, 0, 0, 1) : QuatFromAxisAngle(dispDelta.xyz / deltaAngle, deltaAngle);
    float3 newP1Dir = QuatRotateVector(rotation, p1Dir);
        
    // If the new p1 angle from normal direction is beynond threshold, 
    // and current direction is also within some threshold range
    // Don't move p1, and make velocity zero
    //
    // Else if the new p1 angle will go beyond the threshold
    // but current direction is not within the threhsold range
    // adjust the new angular displacement so that it reaches to the threshold 
    // and make velcity zero.
        
    if (dot(newP1Dir, groundNormal) < BAR_DOT_GROUND_THRESHOLD)
    {
        angularVelocity.xyz = float3(0, 0, 0);
            
        if (abs(dot(p1Dir, groundNormal) - BAR_DOT_GROUND_THRESHOLD) < 0.1)
        {
            angularVelocity.xyz = float3(0, 0, 0);
        }
        else
        {
            dispDelta.xyz = GetCollidingAngleDelta(p1Dir, dispDelta.xyz, groundNormal);
        }

    }
    
    
    float maxAngleDelta = PI_VALUE - P1_ANGLE_THRESHOLD - (bar2StaticAngle + angularDisp.w);
    float minAngleDelta = P1_ANGLE_THRESHOLD - PI_VALUE - (bar2StaticAngle + angularDisp.w);
    
    if (maxAngleDelta < 0)
    {
        maxAngleDelta = 0;
    }
    if (minAngleDelta > 0)
    {
        minAngleDelta = 0;
    }
    
    
    if (dispDelta.w > maxAngleDelta)
    {
        angularVelocity.w = 0;
        dispDelta.w = maxAngleDelta;
        
    }
    else if (dispDelta.w < minAngleDelta)
    {
        angularVelocity.w = 0;
        dispDelta.w = minAngleDelta;
    }
        
    angularDisp += dispDelta;
        
}


float3 GetWindOnlyDistantBarTorque(
    float3 wind_force,
    float3 bar2_rotational_axis,
    float3 bar1_end,
    float3 bar2_end
)
{
    float3 bar2 = (bar2_end - bar1_end);
    float bar2_length = length(bar2);
    float bar2_length_square = bar2_length * bar2_length;
    float3 bar2_dir = bar2 / bar2_length;
        
    float3 bar2_torque_dir = cross(bar2_rotational_axis, bar2_dir);
        
    float3 l0_force_term = wind_force;
    float3 l0_term = cross(bar1_end, l0_force_term);
    float3 l1_term = cross(bar2_dir, l0_force_term);
  
    return l0_term * bar2_length + l1_term * bar2_length_square / 2.0;

}


float3 GetWindOnlyPivotBarTorque(
    float3 wind_force,
    float3 bar
)
{
    float bar_length = length(bar);
    float3 wind_torque = cross(bar, wind_force) * bar_length / 2.0;  
    return bar_length * cross(bar, wind_force) / 2.0;   
}
    

float4 GetApproximateEquilibriumAngularDisplacement(
    float stiffness,
    float p1Stiffness,
    float3 wind,
    float3 scale,
    float2 p1Position,
    FQuat initialOrientation,
    float3 groundNormal
)
{    
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float p1StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);
    
    float3 p1 = float3(p1Position.x, 0, p1Position.y) * scale.x;
    float3 p2 = float3(1, 0, 0) * scale.x;
    p1 = QuatRotateVector(initialOrientation, p1);
    p2 = QuatRotateVector(initialOrientation, p2);
    
    float3 r2_rotational_axis = QuatRotateVector(initialOrientation, float3(0, 1, 0));
    float3 p1p2 = p2 - p1;

    float3 p0Torque = GetWindOnlyPivotBarTorque(
        wind,
        p1
    ) + GetWindOnlyDistantBarTorque(
        wind,
        r2_rotational_axis,
        p1,
        p2
    );
        
    float p1Torque = dot(GetWindOnlyPivotBarTorque(wind, p1p2), r2_rotational_axis);
        
    float4 angularDisp = float4(p0Torque / stiffness, p1Torque / p1Stiffness);
    
    float3 p1Dir = p1 / length(p1);
    
    float dispAngle = length(angularDisp.xyz);
    FQuat rotation = dispAngle < ANGLE_THRESHOLD ? FQuat(0, 0, 0, 1) : QuatFromAxisAngle(angularDisp.xyz / dispAngle, dispAngle);
    float3 newP1Dir = QuatRotateVector(rotation, p1Dir);
        
    // If the new p1 angle from normal direction is beynond threshold, 
    // and current direction is also within some threshold range
    // Don't move p1, and make velocity zero
    //
    // Else if the new p1 angle will go beyond the threshold
    // but current direction is not within the threhsold range
    // adjust the new angular displacement so that it reaches to the threshold 
    // and make velcity zero.
        
    
    if (dot(newP1Dir, groundNormal) < BAR_DOT_GROUND_THRESHOLD)
    {
        if (abs(dot(p1Dir, groundNormal) - BAR_DOT_GROUND_THRESHOLD) < 0.1)
        {
            angularDisp.xyz = float3(0, 0, 0);
        }
        else
        {
            angularDisp.xyz = GetCollidingAngleDelta(p1Dir, angularDisp.xyz, groundNormal);
        }

    }
    
    
    float maxAngle = PI_VALUE - P1_ANGLE_THRESHOLD - p1StaticAngle;
    float minAngle = P1_ANGLE_THRESHOLD - PI_VALUE - p1StaticAngle;
    
    if (maxAngle < 0)
    {
        maxAngle = 0;
    }
    if (minAngle > 0)
    {
        minAngle = 0;
    }
    
    angularDisp.w = angularDisp.w > maxAngle ? maxAngle : angularDisp.w;
    angularDisp.w = angularDisp.w < minAngle ? minAngle : angularDisp.w;
    
    return angularDisp;
    
}

float3 ApproximateAngularDisp(
    float3 wind,
    float3 bar,
    float stiffness
)
{
    float bar_length = length(bar);
    // return bar_length * cross(bar, wind) / 2.0 / stiffness;
    float wind_magnitude = length(wind);
    
    if (wind_magnitude < 0.0001 || bar_length < 0.0001)
    {
        return float3(0, 0, 0);
    }
    
    float bar_wind_angle_cos = dot(wind, bar) / bar_length / wind_magnitude;
    
    // bar and wind is aligned
    if (1 - abs(bar_wind_angle_cos) < 0.001)
    {
        return float3(0, 0, 0);
    }
    
    float3 bar_c_wind = cross(bar, wind);
    float bar_c_wind_length = length(bar_c_wind);
    
    float3 rotational_axis = bar_c_wind / bar_c_wind_length;
    float wind_bar_angle = acos(bar_wind_angle_cos);
    
    // torque from wind 
    float static_wind_torque = bar_length * bar_c_wind_length / 2.0;
    
    // restoration torque, when the bar is rotated to be aligned with the wind direction
    float3 wind_aligned_restoration_torque = stiffness * wind_bar_angle;
    
    //Linearlly approximate the equilibrium angle
    // find t where (t * wind torque) = (1-t) * (wind aligned restoration torque)
    // t = (wind aligned restoration torque) / (wind torque - wind aligned restoration torque)
    // approximated angle = t * (wind bar angle)
    
    return (static_wind_torque) / (static_wind_torque + wind_aligned_restoration_torque) * wind_bar_angle * rotational_axis;

}
    

float4 GetApproximateAngularDisplacement2(
    float stiffness,
    float p1_stiffness,
    float3 wind,
    float3 scale,
    float2 p1Position,
    FQuat initialOrientation,
    float3 ground_normal
)
{
    
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float p1StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);
    
    float3 p1 = float3(p1Position.x, 0, p1Position.y) * scale.x;
    float3 p2 = float3(1, 0, 0) * scale.x;
    p1 = QuatRotateVector(initialOrientation, p1);
    p2 = QuatRotateVector(initialOrientation, p2);
    
    float3 p0Rotation = ApproximateAngularDisp(wind, p1, stiffness);
    
    // If the new p1 angle from normal direction is beynond threshold, 
    // and current direction is also within some threshold range
    // Don't move p1, and make velocity zero
    //
    // Else if the new p1 angle will go beyond the threshold
    // but current direction is not within the threhsold range
    // adjust the new angular displacement so that it reaches to the threshold 
    // and make velcity zero.
    
    float p0RotAngle = length(p0Rotation);
    FQuat p0Quat = p0RotAngle < ANGLE_THRESHOLD ? FQuat(0, 0, 0, 1) : QuatFromAxisAngle(p0Rotation / p0RotAngle, p0RotAngle);
    float bar1_length = length(p1);
    
    float3 bar1_dir = p1 / bar1_length;
    float3 new_bar1 = QuatRotateVector(p0Quat, p1);
    float3 new_bar1_dir = new_bar1 / bar1_length;
    if (dot(new_bar1_dir, ground_normal) < BAR_DOT_GROUND_THRESHOLD)
    {
        if (abs(dot(bar1_dir, ground_normal) - BAR_DOT_GROUND_THRESHOLD) < 0.1)
        {
            p0Rotation = float3(0, 0, 0);
        }
        else
        {
            p0Rotation = GetCollidingAngleDelta(bar1_dir, p0Rotation, ground_normal);
            p0RotAngle = length(p0Rotation);
            p0Quat = p0RotAngle < ANGLE_THRESHOLD ? FQuat(0, 0, 0, 1) : QuatFromAxisAngle(p0Rotation / p0RotAngle, p0RotAngle);
            p1 = QuatRotateVector(p0Quat, p1);
        }

    }
    else
    {
        p1 = new_bar1;
    }
    
    
    p2 = QuatRotateVector(p0Quat, p2);
  
    float3 bar2 = p2 - p1;
    
    float3 p1_rotational_axis = QuatRotateVector(p0Quat, float3(0, 1, 0));
    float3 bar2_wind = wind - dot(wind, p1_rotational_axis) * p1_rotational_axis;
    
    float p1_rotation = dot(ApproximateAngularDisp(bar2_wind, bar2, p1_stiffness), p1_rotational_axis);
    
    
    float max_angle = PI_VALUE - P1_ANGLE_THRESHOLD - p1StaticAngle;
    float min_angle = P1_ANGLE_THRESHOLD - PI_VALUE - p1StaticAngle;
    
    if (max_angle < 0)
    {
        max_angle = 0;
    }
    if (min_angle > 0)
    {
        min_angle = 0;
    }
    
    p1_rotation = p1_rotation > max_angle ?  max_angle : p1_rotation;
    p1_rotation = p1_rotation < min_angle ? min_angle : p1_rotation;
    
    return float4(p0Rotation, p1_rotation);
    
}

#endif //  __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__
