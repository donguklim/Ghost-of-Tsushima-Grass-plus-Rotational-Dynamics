#ifndef __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__
#define __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__

#include "Common/Constants.ush"
#include "Common/BezierCurve.ush"


#define COLLISION_COEFFICENT_TRHESHOLD 0.01
#define WIND_MAGNITUDE_THRESHOLD 0.01


void applyGroundCollision(in float3 barDir, in float3 normal, inout float3 angularDispDelta, inout float3 angularVelocity)
{
    float deltaAngle = length(angularDispDelta);
    if (deltaAngle < ANGLE_THRESHOLD)
    {
        return;
    }
        
    float3 axis = angularDispDelta / deltaAngle;
    float3 axisXBar = cross(axis, barDir);
        
    float aVal = dot(axisXBar, normal);
    float bVal = -dot(cross(axis, axisXBar), normal);
    float cVal = dot(barDir, normal) - bVal - BAR_DOT_GROUND_THRESHOLD;
    
/*
    dot(ground_norm, new bar direction)
        = a * sin(angle delta) + b * cos(angle delta) - b + dot(current bar direction, normal)
    
    dot(ground_norm, new bar direction) - BAR_DOT_GROUND_THRESHOLD  =  a * sin(x) + b * cos(x) + c,
    where c = dot(current bar direction, normal) - b - BAR_DOT_GROUND_THRESHOLD
    
    f(x) = a * sin(x) + b * cos(x) + c
      
    we want to increase x from 0 to the point where f(x) is not positive anymore.
    
    df/dx(x) = a * cos(x) - b * sin(x)
    the critical values of x where df/dx(x) = 0 is 
        
        atan(a/b)
    
    two critical values exist since tan(x) == tan(x + pi)
    
    f maximum is c + a^2 + b^2
    f minimum is c - (a^2 + b^2)
    
*/
    // f(0) = c + a * sin(0) + b * cos(0) = c + b
    // already has collided at x = 0
    if (cVal + bVal < 0.0f)
    {
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = float3(0, 0, 0);
        return;
    }
    
    float absA = abs(aVal);
    float absB = abs(bVal);
    float absC = abs(cVal);
    
    // decreasing angle does not have any effect on ground norm dot value
    if (absA < COLLISION_COEFFICENT_TRHESHOLD && absB < COLLISION_COEFFICENT_TRHESHOLD)
    {
        return;
    }
    
    // f(x) = b * cos(x)
    if (absC < COLLISION_COEFFICENT_TRHESHOLD && absA < COLLISION_COEFFICENT_TRHESHOLD)
    {
        float angleMax = bVal < 0.0f ? 0.0f : 0.5 * PI_VALUE;
        
        if (deltaAngle <= angleMax)
        {
            return;
        }
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = axis * angleMax;
        return;
    }
    
    // f(x) = a * sin(x)
    if (absC < COLLISION_COEFFICENT_TRHESHOLD && absB < COLLISION_COEFFICENT_TRHESHOLD)
    {
        float angleMax = aVal < 0.0f ? 0.0f : PI_VALUE;
        
        if (deltaAngle <= angleMax)
        {
            return;
        }
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = axis * angleMax;
        return;
    }
    
    
    // f(x) = a * sin(x) + b * cos(x)
    if (absC < COLLISION_COEFFICENT_TRHESHOLD)
    {
        float zeroX = atan(-bVal / aVal);
        zeroX = zeroX < 0.0f ? zeroX + PI_VALUE : zeroX;
        
        if (deltaAngle <= zeroX)
        {
            return;
        }
        
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = zeroX * axis;
        return;
    }
    
    // transform f(x) to f(x) = a * sin(x) + b * cos(x) + 1
    // scale does not matter since we want to find value of x where f(x) begins to become negaitve
    
    
    aVal /= cVal;
    bVal /= cVal;
    
    absA = abs(aVal);
    absB = abs(bVal);
    
     // f(x) = 1 + b * cos(x), 
    if (absA < COLLISION_COEFFICENT_TRHESHOLD)
    {

        // no colliding at any angle
        if (absB < 1.0f)
        {
            return;
        }
        
        float allowedAngleMax = acos(-1.0 / bVal);
        if (deltaAngle <= allowedAngleMax)
        {
            return;
        }
        
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = allowedAngleMax * axis;
        return;
    }
    
    //  f(x) = 1 + a * sin(x)
    if (absB < COLLISION_COEFFICENT_TRHESHOLD)
    {
        if (absA < 1.0f)
        {
            return;
        }
        
        float allowedAngleMax = asin(-1.0f / aVal);
        
        allowedAngleMax = allowedAngleMax < 0.0f ? PI_VALUE - allowedAngleMax : allowedAngleMax;
        
        if (deltaAngle < allowedAngleMax)
        {
            return;
        }
        
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = allowedAngleMax * axis;
        return;
    }
    
    float maginitude = sqrt(aVal * aVal + bVal * bVal);
    
    // no colliding at any angle
    if (maginitude < 1.0f)
    {
        return;
    }
    
    /*
        Given a * sin(x) + b * cos(x) = 1
        using trigonometric identity sin(i + j) = sin(i)cos(j) = cos(i)sin(j)
        R * sin(x + z) = 1,  where tan(z) = b/a and R = sqrt(a^2 + b^2)
        x = asin(1/R) + atan(b/a)
    */
    
    float asinVal = asin(1.0 / maginitude);
    float atanVal = atan(bVal / aVal);
    
    /*
        sin(t) = sin(pi - t)
        tan(a) = tan(a + pi)
        need to compare all cases
    
        a + t
        a  + pi - t
        a + pi + t
        a + pi + pi - t = a - t
    */
    float angleSum = asinVal + atanVal;
    float angleSumPlusPi = angleSum + PI_VALUE;
    float angleDiff = atanVal - asinVal;
    float angleDiffPlusPi = angleDiff + PI_VALUE;
    
    angleSum = angleSum < 0.0f ? angleSum + 2 * PI_VALUE : angleSum;
    angleDiff = angleDiff < 0.0f ? angleDiff + 2 * PI_VALUE : angleDiff;
    angleSumPlusPi = angleSumPlusPi < 0.0f ? angleSumPlusPi + 2 * PI_VALUE : angleSumPlusPi;
    angleDiffPlusPi = angleDiffPlusPi < 0.0f ? angleDiffPlusPi + 2 * PI_VALUE : angleDiffPlusPi;
    
    float zeroX = min(min(angleDiff, angleSum), min(angleSumPlusPi, angleDiffPlusPi));
    
    if (deltaAngle <= zeroX)
    {
        return;
    }
    
    angularVelocity = float3(0, 0, 0);
    angularDispDelta = zeroX * axis;

}

void getMaximumUpwardDelta(float3 barDir, float3 normal, inout float3 angularDispDelta, inout float3 angularVelocity)
{
    float deltaAngle = length(angularDispDelta);
    if (deltaAngle < ANGLE_THRESHOLD)
    {
        return;
    }
        
    float3 axis = angularDispDelta / deltaAngle;
    float3 axisXBar = cross(axis, barDir);
        
    float aVal = dot(axisXBar, normal);
    float bVal = dot(cross(axis, axisXBar), normal);
    
    float absA = abs(aVal);
    float absB = abs(bVal);
    
/*
    dot(ground_norm, new bar direction)
        = a * sin(angle delta) - b * cos(angle delta) + b + dot(current bar direction, normal)
    
    f(x) =  a * sin(x) - b * cos(x) + c
    df/dx(x) = a * cos(x) + b * sin(x)
    
    we want to increase x from 0 to the point where df/dx is not positive anymore.
    
    if df/dx(0) < 0
    return zero vector
    Else find x for df/dx(x) == 0
    x = atan(-a/b)
 */
    
    // angular displacement delta does not increase nor decrease the dot value.
    if (absA < COLLISION_COEFFICENT_TRHESHOLD && absB < COLLISION_COEFFICENT_TRHESHOLD)
    {
        return;
    }
    
    //  df/dx(0) = a
    // already negative derievative
    if (aVal < 0.0f)
    {
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = float3(0, 0, 0);
        return;
    }
            
    // df/dx(0) = b * sin(x)
    if (absA < COLLISION_COEFFICENT_TRHESHOLD)
    {
        if (bVal < 0.0f)
        {
            angularVelocity = float3(0, 0, 0);
            angularDispDelta = float3(0, 0, 0);
            return;
        }
        
        if (deltaAngle < PI_VALUE)
        {
            return;
        }
        
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = axis * PI_VALUE;
        return;
    }
    
    // df/dx(x) = a * cos(x)
    // a is positive by above df/dx(0) check
    if (absB < COLLISION_COEFFICENT_TRHESHOLD)
    {   
        if (deltaAngle < 0.5 * PI_VALUE)
        {
            return;
        }
        
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = axis * 0.5 * PI_VALUE;
        return;
    }
        
    float xVal = atan(-aVal / bVal);
    xVal = xVal < 0.0f ? xVal + PI_VALUE : xVal;
    
    if (xVal < deltaAngle)
    {
        angularVelocity = float3(0, 0, 0);
        angularDispDelta = xVal * axis;
    }

}


/*
   Scale down angulr displacement delta so that
    |current angular displacement + angular displacement delta| < 2 PI
*/
void limitAngleDispScale(in float3 angularDisp, inout float3 angularDispDelta, inout float3 angularVelocity)
{
    
    float deltaAngle = length(angularDispDelta.xyz);
    if (deltaAngle < ANGLE_THRESHOLD)
    {
        return;
    }
    
    float leftMarginSquare = 4 * PI_VALUE * PI_VALUE - dot(angularDisp, angularDisp);
    // already exceeded the limit
    if (leftMarginSquare < 0.0f)
    {
        angularDispDelta = 0.0f;
        angularVelocity = 0.0f;
        return;
    }
        
    float3 axis = angularDispDelta.xyz / deltaAngle;
    
     /*
        let 
            disp = square of current angular displacement
    
            f(x) = (2 PI)^2 - |disp + x * axis|^2 
                 = -x^2 - 2 dot(axis, disp) * x + 4*PI^2 -  |disp|^2
    
        we want to increase x from 0 to the point where f(x) is no longer positive
    
        the x for f(x) == 0 can be solved by solving the quadratic equation.
   
    */
    
    float axisDotDisp = dot(axis, angularDisp); 
    float discriminant = -4 * leftMarginSquare - 4 * axisDotDisp * axisDotDisp;
       
    // magnitude of delta angle cannot make angular displacement to breach the threshold
    if (discriminant < 0.0f)
    {
        return;
    }
    
    float sqrtDiscriminant = sqrt(discriminant);
        
    float maxAngleCandidateMax = -axisDotDisp + sqrtDiscriminant / 2.0f;
    float maxAngleCandidateMin = -axisDotDisp - sqrtDiscriminant / 2.0f;
    
    // No positive delta angle can breach the limit
    if (maxAngleCandidateMax < 0.0f)
    {
        return;
    }
    
    // choose the minimum of the positive values
    float maxAngle = maxAngleCandidateMin < 0 ? maxAngleCandidateMax : maxAngleCandidateMin;
    if (deltaAngle < maxAngle)
    {
        return;
    }
    
    angularDispDelta = maxAngle * axis;
    angularVelocity = 0.0f;
}


void getAngleDispScaleDecreasingDelta(in float3 angularDisp, inout float3 angularDispDelta, inout float3 angularVelocity)
{
    
    float deltaAngle = length(angularDispDelta);
    if (deltaAngle < ANGLE_THRESHOLD)
    {
        return;
    }
        
    float3 axis = angularDispDelta / deltaAngle;
    
    
     /*
        let 
            disp = square of current angular displacement
    
            f(x) = (2 PI)^2 - |disp + x * axis|^2 
                 = -x^2 - 2 dot(axis, disp) * x + 4*PI^2 -  |disp|^2
    
        then, df/dx(x) = -2x - 2 dot(axis, disp)
    
        we want to increase x from 0 to the point where df/dx(x) is no longer positive.
    
    */
    
    float axisDotDisp = dot(axis, angularDisp);
    
    // df/dx is alreaydy negative at 0
    if (axisDotDisp > 0)
    {
        angularDispDelta = 0.0f;
        angularVelocity = 0.0f;
        return;
    }
    
    if (deltaAngle < -axisDotDisp)
    {
        return;
    }
    
    angularDispDelta = -axisDotDisp * axis;
    angularVelocity = 0.0f;
    
}


float3 GetBar2TorqueOnP0(
    float dampingCoeff,
    float3 windForce,
    float3 bar1AngularVelocity,
    float3 bar1,
    float bar2AngularVelocity,
    float3 bar2RotationalAxis,
    float3 bar2
)
{
    float bar2Length = length(bar2);
    float3 axisCrossBar2 = cross(bar2RotationalAxis, bar2);
    float windMag = length(windForce);
    float3 bar2CrossWind = cross(bar2, windForce);
        
    float3 l0ForceTerm = (windMag > WIND_MAGNITUDE_THRESHOLD ? length(bar2CrossWind) / (windMag * bar2Length) : 0.0f) * windForce 
        - dampingCoeff * cross(bar1AngularVelocity, bar1);
    float3 l1ForceTerm = -dampingCoeff * (bar2AngularVelocity * axisCrossBar2 + cross(bar1AngularVelocity, bar2));
    float3 l0Term = cross(bar1, l0ForceTerm);
    float3 l1Term = cross(bar2, l0ForceTerm) + cross(bar1, l1ForceTerm);
    float3 l2Term = cross(bar2, l1ForceTerm);
        
    return bar2Length * (l0Term + l1Term / 2.0f + l2Term / 3.0f);

}

float3 GetPivotBarTorque(
    float dampingCoff,
    float3 windForce,
    float3 bar,
    float3 angularVelocity
)
{
    float barLength = length(bar);
    float3 barCrossWind = cross(bar, windForce);
    float windMag = length(windForce);
   
    return (windMag > WIND_MAGNITUDE_THRESHOLD ? length(barCrossWind) * barCrossWind / windMag : 0.0f)
        - dampingCoff / 3.0f * barLength  * cross(bar, cross(angularVelocity, bar));
}

float3 GetBar2Torque(
    float dampingCoeff,
    float3 windForce,
    float3 bar1AngularVelocity,
    float3 bar1,
    float bar2AngularVelocity,
    float3 bar2
)
{
    float bar2Length = length(bar2);
    return GetPivotBarTorque(dampingCoeff, windForce, bar2, float3(0, 1, 0) * bar2AngularVelocity)
        - dampingCoeff * bar2Length * (cross(bar2, cross(bar1AngularVelocity, bar1)) / 2.0f + cross(bar2, cross(bar1AngularVelocity, bar2)) / 3.0f);

}

float3 GetBar1PaybackForceFromBar2(
    in float dampingCoff,
    in float stiffness,
    in float3 windForce,
    in float3 bar2,
    in float3 bar2RotationalAxis,
    in float angualrVelocity,
    in float angularDisplacement
)
{
    
    float barLength = length(bar2);
    
    float windMag = length(windForce);
    float3 barCrossWind = cross(bar2, windForce);

    return cross(bar2RotationalAxis, bar2) * (
            stiffness * angularDisplacement / barLength / barLength
            + dampingCoff * angualrVelocity * barLength * 5.0f / 16.0f
        )
        - (windMag > WIND_MAGNITUDE_THRESHOLD ? length(barCrossWind) / windMag : 0.0f) * windForce / 4.0f;
}
    
    
float GetMomentOfInertia(float segmentDensity, float3 bar1, float3 p2)
{
    float3 bar2 = p2 - bar1;
    float bar2Length = length(bar2);
    float bar1Length = length(bar1);
    // bar2 center distance from pivot (0, 0, 0)
    float bar2CenterDistance = length(bar2 / 2 + bar1);
        
    float bar2Mass = segmentDensity * bar2Length;
    float bar1Mass = segmentDensity * bar1Length;
    
    // Moment of Inertia caused by bar 2
    // = Moment of Inertia of bar2 at its center of mass + (bar 2 center of mass distance from the pivot)^2
    //
    // Moment of Inertia of bar 2 at its center of mass = bar2_mass * bar2_length * bar2_length / 12.0
    float bar2MomentOfIntertia = bar2Mass * (bar2Length * bar2Length / 12.0 + bar2CenterDistance * bar2CenterDistance);
        
    float bar1MomentOfIntertia = (bar1Mass) / 3.0 * bar1Length * bar1Length;
        
    return bar1MomentOfIntertia + bar2MomentOfIntertia;
    
}

float Get2DAngle(float2 vec)
{
    float vecLength = length(vec);
    if (vecLength < ANGLE_THRESHOLD)
    {
        return 0.0f;
    }
    
    float2 normalizedVector = vec / vecLength;
    
    float angle = acos(normalizedVector.x);
 
    if (normalizedVector.y > 0)
    {
        angle = -angle;
    }
    
    return angle;
}

/*
Using articulated body algorithm from FeatherStone's book
*/

void SpatialMatMul(in float3x3 mat1[2][2], in float3x3 mat2[2][2], out float3x3 matOut[2][2])
{
    matOut[0][0] = mat1[0][0] * mat2[0][0] + mat1[0][1] * mat2[1][0];
    matOut[1][0] = mat1[1][0] * mat2[0][0] + mat1[1][1] * mat2[1][0];
    
    matOut[0][1] = mat1[0][0] * mat2[0][1] + mat1[0][1] * mat2[1][1];
    matOut[1][1] = mat1[1][0] * mat2[0][1] + mat1[1][1] * mat2[1][1];
}

void SpatialMatVectorMul(in float3x3 mat[2][2], in float3 inVec[2], out float3 outVec[2])
{
    outVec[0] = mul(mat[0][0], inVec[0]) + mul(mat[0][1], inVec[1]);
    outVec[1] = mul(mat[1][0], inVec[0]) + mul(mat[1][1], inVec[1]);
}

float3x3 getLeftCrossMat(in float3 vec)
{
    return float3x3(
        0, -vec.z, vec.y,
        vec.z, 0, -vec.x,
        -vec.y, vec.x, 0
    );
}

void getSpatialVelocityTransformaton(
    in float3 trans,
    in float3 rotation,
    out float3x3 result[2][2]
)
{
    float angle = length(rotation);
    
    float3x3 rotationMat = angle < ANGLE_THRESHOLD ? float3x3(
        1, 0, 0,
        0, 1, 0,
        0, 0, 1
    ) : QuatToMatrix(QuatFromAxisAngle(rotation / angle, angle));
    
    result[0][1] = 0;
    result[0][0] = rotationMat;
    result[1][1] = rotationMat;
    result[1][0] = -rotationMat * getLeftCrossMat(trans);

}

void getSpatialForceTransformaton(
    in float3 trans,
    in float3 rotation,
    out float3x3 result[2][2]
)
{
    float angle = length(rotation);
    
    float3x3 rotationMat = angle < ANGLE_THRESHOLD ? float3x3(
        1, 0, 0,
        0, 1, 0,
        0, 0, 1
    ) : QuatToMatrix(QuatFromAxisAngle(rotation / angle, angle));
    
    result[1][0] = 0;
    result[0][0] = rotationMat;
    result[1][1] = rotationMat;
    result[0][1] = -rotationMat * getLeftCrossMat(trans);
}

void spatioalVelocityCross(in float3 vec1[2], in float3 vec2[2], out float3 outVec[2])
{
    outVec[0] = cross(vec1[0], vec2[0]);
    outVec[1] = cross(vec1[0], vec2[1]) + cross(vec1[1], vec2[0]);

}
 
void spatialForceCross(in float3 vec1[2], in float3 vec2[2], out float3 outVec[2])
{
    outVec[0] = cross(vec1[0], vec2[0]) + cross(vec1[1], vec2[1]);
    outVec[1] = cross(vec1[0], vec2[1]);

}

float3x3 OuterProduct(float3 a, float3 b)
{
    return float3x3(
        a.x * b,
        a.y * b,
        a.z * b
    );
}

float3x3 PseudoInverseInertia(float3x3 A)
{
    // Compute the determinant
    float detA = determinant(A);
    
    // Compute the cofactor matrix (adjugate)
    float3x3 adjA = float3x3(
        A._22 * A._33 - A._23 * A._32, -(A._12 * A._33 - A._13 * A._32), (A._12 * A._23 - A._13 * A._22),
       -(A._21 * A._33 - A._23 * A._31), A._11 * A._33 - A._13 * A._31, -(A._11 * A._23 - A._13 * A._21),
        A._21 * A._32 - A._22 * A._31, -(A._11 * A._32 - A._12 * A._31), A._11 * A._22 - A._12 * A._21
    );
    
    // If determinant is very small, regularize
    float epsilon = 1e-5;
    if (abs(detA) < epsilon)
    {
        // Compute a symmetric damped version of A
        A += epsilon * float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);
        detA = determinant(A);
        adjA = float3x3(
            A._22 * A._33 - A._23 * A._32, -(A._12 * A._33 - A._13 * A._32), (A._12 * A._23 - A._13 * A._22),
           -(A._21 * A._33 - A._23 * A._31), A._11 * A._33 - A._13 * A._31, -(A._11 * A._23 - A._13 * A._21),
            A._21 * A._32 - A._22 * A._31, -(A._11 * A._32 - A._12 * A._31), A._11 * A._22 - A._12 * A._21
        );
    }
    
    // Compute inverse (or pseudo-inverse approximation)
    float3x3 R = adjA / detA;
    
    // Ensure symmetry
    R = 0.5 * (R + transpose(R));
    
    return R;
}

 

void GrassUpdate(
    float dampingCoff,
    in float massDensity,
    float stiffness,
    float p1Stiffness,
    in float timeDelta,
    in float3 wind,
    in FQuat initialOrientation,
    in float3 scale,
    in float2 p1Position,
    float3 groundNormal,
    inout float4 angularVelocity,
    inout float4 angularDisp
)
{
    
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float bar2StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);
    float segmentMassDensity = scale.y * massDensity;
    segmentMassDensity = segmentMassDensity < 0.01f ? 1.0f : segmentMassDensity;
    
    wind *= scale.y;
    dampingCoff *= scale.y;
    
    float3 staticP1 = float3(p1Position.x, 0, p1Position.y) * scale;
    float3 staticP2 = float3(1, 0, 0) * scale;
    staticP1 = QuatRotateVector(initialOrientation, staticP1);
    staticP2 = QuatRotateVector(initialOrientation, staticP2);
    float3 bar2RotationalAxis = QuatRotateVector(initialOrientation, float3(0, 1, 0));

    float3 p1 = float3(0, 0, 0);
    float3 p2 = float3(0, 0, 0);
    FQuat bar1Quat;

    
    GetRotatedBezierPoints(staticP1, staticP2, bar2RotationalAxis, angularDisp, p1, p2, bar2RotationalAxis, bar1Quat);
    
    FQuat bar1ReverseQuat = FQuat(-bar1Quat.xyz, bar1Quat.w);
    
    float3 bar1Dir = normalize(p1);
    
    float radius = 0.05f * scale.y;
    
    float3 bar2 = p2 - p1;
    float3 bar2Dir = normalize(bar2);
    
    float bar1Length = length(p1);
    float bar2Length = length(bar2);
        
    float bar1Mass = segmentMassDensity * bar1Length * scale.y;
    float bar2Mass = segmentMassDensity * bar2Length * scale.y;

    
    float bar1InertiaVal = bar1Mass * (3.0f * radius * radius + 4.0f * bar1Length * bar1Length) / 12.0f;
    float3x3 bar1BaseInertiaTensor = float3x3(
        bar1Mass * radius * radius / 2.0f, 0.0f, 0.0f,
        0.0f, bar1InertiaVal, 0.0f,
        0.0f, 0.0f, bar1InertiaVal
    );
    
    float bar2InertiaVal = bar2Mass * (3.0f * radius * radius * 3.0f + 4.0f * bar2Length * bar1Length) / 12.0f;
    float3x3 bar2BaseInertiaTensor = float3x3(
            bar2Mass * radius * radius / 2.0f, 0.0f, 0.0f,
            0.0f, bar2InertiaVal, 0.0f,
            0.0f, 0.0f, bar2InertiaVal
    );
    
    float3 localBar1 = float3(bar1Length, 0, 0);
 
    float3 bar1Velocity[2];
    float3 bar1BiasForce[2];
    float3 bar1Momentum[2];
    
    bar1Velocity[0] = QuatRotateVector(bar1ReverseQuat, angularVelocity.xyz);
    bar1Velocity[1] = 0;

    bar1Momentum[0] = mul(bar1BaseInertiaTensor, bar1Velocity[0]);
    bar1Momentum[1] = 0;
    
    spatialForceCross(bar1Velocity, bar1Momentum, bar1BiasForce);
    
    float3 bar1ExternalTorque = GetPivotBarTorque(
        dampingCoff,
        QuatRotateVector(bar1ReverseQuat, wind),
        localBar1,
        bar1Velocity[0]
    );
    
    bar1BiasForce[1] -= bar1ExternalTorque;
    float3 generalizedBar1Torque = bar1ExternalTorque - stiffness * QuatRotateVector(bar1ReverseQuat, angularDisp.xyz);
    
    float3x3 zeroMat = float3x3(
        0, 0, 0,
        0, 0, 0,
        0, 0, 0
    );

    float3x3 bar1ToBar2VelTransformation[2][2] = {
        { zeroMat, zeroMat },
        { zeroMat, zeroMat }
    };
    getSpatialVelocityTransformaton(localBar1, float3(0, -(bar2StaticAngle + angularDisp.w), 0), bar1ToBar2VelTransformation);
    
    
    float3 bar2Velocity[2];
    float3 bar2BiasForce[2];
    float3 bar2Momentum[2];
    float3 bar2VelocityProductAcc[2];

    float3 bar2LocalVelocity[2];
    bar2LocalVelocity[0] = float3(0, angularVelocity.w, 0);
    bar2LocalVelocity[1] = 0;
    SpatialMatVectorMul(bar1ToBar2VelTransformation, bar1Velocity, bar2Velocity);
    bar2Velocity[0] += bar2LocalVelocity[0];
    
    spatioalVelocityCross(bar2Velocity, bar2LocalVelocity, bar2VelocityProductAcc);
    
    bar2Momentum[0] = mul(bar2BaseInertiaTensor, bar2Velocity[0]);
    bar2Momentum[1] = bar2Mass * bar2Velocity[1];
    
    spatialForceCross(bar2Velocity, bar2Momentum, bar2BiasForce);
    
    float p0Angle = length(angularDisp.xyz);
    FQuat bar2FrameQuat =  p0Angle < ANGLE_THRESHOLD ? FQuat(0, 0, 0, 1) : QuatFromAxisAngle(angularDisp.xyz / p0Angle, -p0Angle);
    
    bar2FrameQuat = angularDisp.w < ANGLE_THRESHOLD ? bar2FrameQuat : QuatMultiply(QuatFromAxisAngle(bar2RotationalAxis, -angularDisp.w), bar2FrameQuat);
    float3 bar2ExternalTorque = GetBar2Torque(
        dampingCoff,
        QuatRotateVector(bar2FrameQuat, wind),
        QuatRotateVector(bar2FrameQuat, angularVelocity.xyz),
        QuatRotateVector(bar2FrameQuat, localBar1),
        angularVelocity.w,
        float3(bar2Length, 0, 0)
    );
    
    bar2BiasForce[1] -= bar2ExternalTorque; 
    float bar2GeneralizedTorque = dot(bar2ExternalTorque, float3(0, 1, 0)) - p1Stiffness * angularDisp.w;
   
    float3x3 bar2InertiaTensorOnBar1[2][2] = {
        { zeroMat, zeroMat },
        { zeroMat, zeroMat }
    };
    bar2InertiaTensorOnBar1[0][0] = bar2BaseInertiaTensor;
    bar2InertiaTensorOnBar1[1][1] = float3x3(
        bar2Mass, 0, 0,
        0, bar2Mass, 0,
        0, 0, bar2Mass
    );
   
    
    float3 bar2InertiaYColum[2];
    bar2InertiaYColum[0] = float3(bar2InertiaTensorOnBar1[0][0][1][0], bar2InertiaTensorOnBar1[0][0][1][1], bar2InertiaTensorOnBar1[0][0][1][2]);
    bar2InertiaYColum[1] = float3(bar2InertiaTensorOnBar1[1][0][1][0], bar2InertiaTensorOnBar1[1][0][1][1], bar2InertiaTensorOnBar1[1][0][1][2]);
    
    
    float weightVal = (bar2GeneralizedTorque - bar2BiasForce[0][1]) / bar2InertiaTensorOnBar1[0][0][1][1];
    
    float3 bar1BiasForceFromBar2[2];
    bar1BiasForceFromBar2[0] = bar2BiasForce[0] + bar2InertiaYColum[0] * weightVal;
    bar1BiasForceFromBar2[1] = bar2BiasForce[1] + bar2InertiaYColum[1] * weightVal;
    
    bar2InertiaTensorOnBar1[0][0] -= OuterProduct(bar2InertiaYColum[0], bar2InertiaYColum[0]) / bar2InertiaTensorOnBar1[0][0][1][1];
    bar2InertiaTensorOnBar1[0][1] -= OuterProduct(bar2InertiaYColum[0], bar2InertiaYColum[1]) / bar2InertiaTensorOnBar1[0][0][1][1];
    
    bar2InertiaTensorOnBar1[1][0] -= OuterProduct(bar2InertiaYColum[1], bar2InertiaYColum[0]) / bar2InertiaTensorOnBar1[0][0][1][1];
    bar2InertiaTensorOnBar1[1][1] -= OuterProduct(bar2InertiaYColum[1], bar2InertiaYColum[1]) / bar2InertiaTensorOnBar1[0][0][1][1];
    
    float3 tempSpatialVec[2];
    SpatialMatVectorMul(bar2InertiaTensorOnBar1, bar2VelocityProductAcc, tempSpatialVec);
    bar1BiasForceFromBar2[0] += tempSpatialVec[0];
    bar1BiasForceFromBar2[1] += tempSpatialVec[1];
    
    float3x3 bar2ToBar1ForceTransformation[2][2] =
    {
        { zeroMat, zeroMat },
        { zeroMat, zeroMat }
    };
    getSpatialForceTransformaton(-localBar1, float3(0, (bar2StaticAngle + angularDisp.w), 0), bar2ToBar1ForceTransformation);
    
    SpatialMatVectorMul(bar2ToBar1ForceTransformation, bar1BiasForceFromBar2, bar1BiasForceFromBar2);
    bar1BiasForce[0] += bar1BiasForceFromBar2[0];
    // bar1BiasForce[1] += bar1BiasForceFromBar2[1];

    
    SpatialMatMul(bar2InertiaTensorOnBar1, bar1ToBar2VelTransformation, bar2InertiaTensorOnBar1);
    SpatialMatMul(bar2ToBar1ForceTransformation, bar2InertiaTensorOnBar1, bar2InertiaTensorOnBar1);

    /*
    float3x3 bar1InertiaTensor[2][2];
    bar1InertiaTensor[0][0] = bar1BaseInertiaTensor;
    
    bar1InertiaTensor[1][1] = float3x3(
        bar1Mass, 0, 0,
        0, bar1Mass, 0,
        0, 0, bar1Mass
    );
    
    bar1InertiaTensor[1][1] = 0;
    
    bar1InertiaTensor[0][1] = 0;
    bar1InertiaTensor[1][0] = 0;
    
    bar1InertiaTensor[0][0] += bar2InertiaTensorOnBar1[0][0];
    bar1InertiaTensor[1][0] += bar2InertiaTensorOnBar1[1][0];
    bar1InertiaTensor[0][1] += bar2InertiaTensorOnBar1[0][1];
    bar1InertiaTensor[1][1] += bar2InertiaTensorOnBar1[1][1];
    */
    
    float3x3 inverseInertia = 1.0 / (bar1BaseInertiaTensor + bar2InertiaTensorOnBar1[0][0]);
    
    float3 p0Acc = mul(
        PseudoInverseInertia(bar1BaseInertiaTensor + bar2InertiaTensorOnBar1[0][0]),
        generalizedBar1Torque
        - mul(bar2InertiaTensorOnBar1[0][1], QuatRotateVector(bar1ReverseQuat, float3(0, 0, 0)))
        - bar1BiasForce[0]
    );
    
    p0Acc = 
        generalizedBar1Torque
        - mul(bar2InertiaTensorOnBar1[0][1], QuatRotateVector(bar1ReverseQuat, float3(0, 0, 0)))
        - bar1BiasForce[0];

    float p1Acc = (
        bar2GeneralizedTorque - mul(bar2BaseInertiaTensor, p0Acc + bar2VelocityProductAcc[0])[1] - bar2BiasForce[0][1]
    ) / bar2BaseInertiaTensor[1][1];
    
   
    float4 velocityDelta = float4(p0Acc, p1Acc) * timeDelta;
    
    angularVelocity += velocityDelta;
        
    float4 dispDelta = angularVelocity * timeDelta; 
    

    // Limit P1 angle displacement so that bar1 does not touch bar2.
    float maxP1AngleDelta = PI_VALUE - P1_ANGLE_THRESHOLD - (bar2StaticAngle + angularDisp.w);
    float minP1AngleDelta = P1_ANGLE_THRESHOLD - PI_VALUE - (bar2StaticAngle + angularDisp.w);
    
    maxP1AngleDelta = maxP1AngleDelta < 0 ? 0 : maxP1AngleDelta;
    minP1AngleDelta = minP1AngleDelta > 0 ? 0 : minP1AngleDelta;
    
    
    if (p0Angle < 2 * PI_VALUE)
    {
        limitAngleDispScale(angularDisp.xyz, dispDelta.xyz, angularVelocity.xyz);
    }
    else
    {
        getAngleDispScaleDecreasingDelta(angularDisp.xyz, dispDelta.xyz, angularVelocity.xyz);
    }

    if (dispDelta.w < minP1AngleDelta || maxP1AngleDelta < dispDelta.w)
    {
        angularVelocity.w = 0;
        dispDelta.w = clamp(dispDelta.w, minP1AngleDelta, maxP1AngleDelta);
    }
    
    if (dot(bar1Dir, groundNormal) < BAR_DOT_GROUND_THRESHOLD)
    {
        getMaximumUpwardDelta(bar1Dir, groundNormal, dispDelta.xyz, angularVelocity.xyz);
    }
    else
    {
        applyGroundCollision(bar1Dir, groundNormal, dispDelta.xyz, angularVelocity.xyz);
    }
    
    angularDisp += dispDelta;
        
}


float3 GetWindOnlyDistantBarTorque(
    float3 windForce,
    float3 bar2RotationalAxis,
    float3 bar1,
    float3 bar2
)
{
    
    float bar2Length = length(bar2);
    float windMag = length(windForce);
    float3 bar2CrossWind = cross(bar2, windForce);
        
    float3 l0ForceTerm = (windMag > WIND_MAGNITUDE_THRESHOLD ? length(bar2CrossWind) / (windMag * bar2Length) : 0.0f) * windForce;
    float3 l0Term = cross(bar1, l0ForceTerm);
    float3 l1Term = cross(bar2, l0ForceTerm) ;
        
    return bar2Length * (l0Term + l1Term / 2.0f);
}


float3 GetWindOnlyPivotBarTorque(
    float3 windForce,
    float3 bar
)
{
    float bar_length = length(bar);
    float3 barCrossWind = cross(bar, windForce);
    float windMag = length(windForce);
   
    return (windMag > WIND_MAGNITUDE_THRESHOLD ? length(barCrossWind) * barCrossWind / windMag : 0.0f);
}
    

float4 GetApproximateEquilibriumAngularDisplacement(
    float stiffness,
    float p1Stiffness,
    float3 wind,
    float3 scale,
    float2 p1Position,
    FQuat initialOrientation,
    float3 groundNormal
)
{    
    float2 p1p2XZ = float2(1, 0) - p1Position;
    float p1StaticAngle = Get2DAngle(p1p2XZ) - Get2DAngle(p1Position);
    
    float3 p1 = float3(p1Position.x, 0, p1Position.y) * scale.x;
    float3 p2 = float3(1, 0, 0) * scale.x;
    p1 = QuatRotateVector(initialOrientation, p1);
    p2 = QuatRotateVector(initialOrientation, p2);
    
    float3 r2_rotational_axis = QuatRotateVector(initialOrientation, float3(0, 1, 0));
    float3 bar2 = p2 - p1;

    float3 p0Torque = GetWindOnlyPivotBarTorque(
        wind,
        p1
    ) + GetWindOnlyDistantBarTorque(
        wind,
        r2_rotational_axis,
        p1,
        bar2
    );
        
    float p1Torque = dot(GetWindOnlyPivotBarTorque(wind, bar2), r2_rotational_axis);
        
    float4 angularDisp = float4(p0Torque / stiffness, p1Torque / p1Stiffness);
    float dispAngle = length(angularDisp.xyz);
    if (dispAngle > ANGLE_THRESHOLD)
    {
        angularDisp.xyz = angularDisp.xyz / dispAngle * ANGLE_THRESHOLD;

    }
    
    // Limit P1 angle displacement so that bar1 does not touch bar2.
    float maxP1AngleDelta = PI_VALUE - P1_ANGLE_THRESHOLD - (p1StaticAngle + angularDisp.w);
    float minP1AngleDelta = P1_ANGLE_THRESHOLD - PI_VALUE - (p1StaticAngle + angularDisp.w);
    
    maxP1AngleDelta = maxP1AngleDelta < 0 ? 0 : maxP1AngleDelta;
    minP1AngleDelta = minP1AngleDelta > 0 ? 0 : minP1AngleDelta;
    

    if (angularDisp.w < minP1AngleDelta || maxP1AngleDelta < angularDisp.w)
    {
        angularDisp.w = clamp(angularDisp.w, minP1AngleDelta, maxP1AngleDelta);
    }
    
    float3 bar1Dir = p1 / length(p1);
    float3 zero = float3(0, 0, 0);
    
    if (dot(bar1Dir, groundNormal) < BAR_DOT_GROUND_THRESHOLD)
    {
        getMaximumUpwardDelta(bar1Dir, groundNormal, angularDisp.xyz, zero);
    }
    else
    {
        applyGroundCollision(bar1Dir, groundNormal, angularDisp.xyz, zero);
    }
    
    
    return angularDisp;
    
}

#endif //  __ROTATIONAL_DYNAMIC_GRASS_MOTION_HLSL__
